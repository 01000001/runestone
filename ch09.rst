..  Copyright (C)  Jeffrey Elkner, Peter Wentworth, Allen B. Downey, Chris
    Meyers, and Dario Mitchell.  Permission is granted to copy, distribute
    and/or modify this document under the terms of the GNU Free Documentation
    License, Version 1.3 or any later version published by the Free Software
    Foundation; with Invariant Sections being Forward, Prefaces, and
    Contributor List, no Front-Cover Texts, and no Back-Cover Texts.  A copy of
    the license is included in the section entitled "GNU Free Documentation
    License".
    
.. index:: list, element, sequence, collection    
    
Lists
=====

A **list** is a sequential collection of Python data values, where each value is identified by an
index. The values that make up a list are called its **elements**. Lists are
similar to strings, which are ordered collections of characters, except that the
elements of a list can have any type and for any one list, the items can be of different types.

.. index:: nested list, list; nested

List values
-----------

There are several ways to create a new list.  The simplest is to enclose the
elements in square brackets ( ``[`` and ``]``):

.. sourcecode:: python
    
    [10, 20, 30, 40]
    ["spam", "bungee", "swallow"]

The first example is a list of four integers. The second is a list of three
strings. As we said above, the elements of a list don't have to be the same type.  The following
list contains a string, a float, an integer, and
another list:

.. sourcecode:: python
    
    ["hello", 2.0, 5, [10, 20]]

A list within another list is said to be **nested**.
Finally, there is a special list that contains no elements. It is called the
empty list, and is denoted ``[]``.

As you would expect, we can also assign list values to variables and pass lists as parameters to functions.  

.. activecode:: chp09_01
    
    vocabulary = ["ameliorate", "castigate", "defenestrate"]
    numbers = [17, 123]
    empty = []
    print(vocabulary, numbers, empty)


.. _accessing-elements:

.. index:: list index, index, list traversal

List length
-----------

As with strings, the function ``len`` returns the length of a list (the number
of items in the list).  However, since lists can have items which are themselves lists, it important to note
that ``len`` only returns the top-most length.  In other words, sublists are considered to be a single
item when counting the length of the list.

.. activecode:: chp09_01a

    alist =  ["hello", 2.0, 5, [10, 20]]
    print(len(alist))
    print(len(['spam!', 1, ['Brie', 'Roquefort', 'Pol le Veq'], [1, 2, 3]]))



Accessing elements
------------------

The syntax for accessing the elements of a list is the same as the syntax for
accessing the characters of a string.  We use the index operator ( ``[]`` -- not to
be confused with an empty list). The expression inside the brackets specifies
the index. Remember that the indices start at 0.  Any integer expression can be used
as an index and as with strings, negative index values will locate items from the right instead
of from the left.

.. activecode:: chp09_02
    
    numbers = [17, 123, 87, 34, 66, 8398, 44]
    print(numbers[2])
    print(numbers[9-8])
    print(numbers[-2])
 





List membership
---------------

``in`` and ``not in`` are boolean operators that test membership in a sequence. We
used them previously with strings and they also work here.

.. activecode:: chp09_4
    
    fruit = ["apple","orange","banana","cherry"]

    print("apple" in fruit)
    print("pear" in fruit)


Concatenation and Repetition
----------------------------

Again, as with strings, the ``+`` operator concatenates lists.  
Similarly, the ``*`` operator repeats a list a given number of times:

.. activecode:: chp09_5

    fruit = ["apple","orange","banana","cherry"]
    print([1,2] + [3,4])
    print(fruit+[6,7,8,9])

    print([0] * 4)
    print([1,2,["hello","goodbye"]]*2)


List slices
-----------

The slice operations we saw with strings also work on lists.

.. activecode:: chp09_6
    
    a_list = ['a', 'b', 'c', 'd', 'e', 'f']
    print(a_list[1:3])
    print(a_list[:4])
    print(a_list[3:])
    print(a_list[:])

.. index:: mutable, item assignment, immutable
    
Lists are mutable
-----------------

Unlike strings, lists are **mutable**.  This means we can change an item in a list by accessing
it directly as part of the assignment statement. Using the bracket operator on the left side of an assignment, we can
update one of the list items.

.. activecode:: ch09_7
    
    fruit = ["banana", "apple", "cherry"]
    fruit[0] = "pear"
    fruit[-1] = "orange"
    print(fruit)


An
assignment to an element of a list is called **item assignment**. Item
assignment does not work for strings.  Recall that strings are immutable.

By combining assignment with the slice operator we can update several elements at once.

.. activecode:: ch09_8
    
    alist = ['a', 'b', 'c', 'd', 'e', 'f']
    alist[1:3] = ['x', 'y']
    print(alist)

We can also remove elements from a list by assigning the empty list to them.

.. activecode:: ch09_9
    
    alist = ['a', 'b', 'c', 'd', 'e', 'f']
    alist[1:3] = []
    print(alist)

We can even insert elements into a list by squeezing them into an empty slice at the
desired location.

.. activecode:: ch09_10
    
    alist = ['a', 'd', 'f']
    alist[1:1] = ['b', 'c']
    print(alist)
    alist[4:4] = ['e']
    print(alist)


.. index:: del statement, statement; del

List deletion
-------------

Using slices to delete list elements can be awkward, and therefore error-prone.
Python provides an alternative that is more readable.
The ``del`` statement removes an element from a list by using its position.

.. activecode:: ch09_11
    
    a = ['one', 'two', 'three']
    del a[1]
    print(a)

    alist = ['a', 'b', 'c', 'd', 'e', 'f']
    del alist[1:5]
    print(alist)

As you might expect, ``del`` handles negative indices and causes a runtime
error if the index is out of range.
In addition, you can use a slice as an index for ``del``.
As usual, slices select all the elements up to, but not including, the second
index.

.. index:: is operator, objects and values

Objects and values
------------------

If we execute these assignment statements,

.. sourcecode:: python
    
    a = "banana"
    b = "banana"

we know that ``a`` and ``b`` will refer to a string with the letters
``"banana"``. But we don't know yet whether they point to the *same* string.

There are two possible ways the Python interpreter could arrange its internal states:

.. image:: illustrations/ch09/list1.png
   :alt: List illustration 

In one case, ``a`` and ``b`` refer to two different things that have the same
value. In the second case, they refer to the same thing. These things have
names --- they are called **objects**. An object is something a variable can
refer to.

We can test whether two names refer to the same object using the *is*
operator: 

.. activecode:: chp09_is1

    a = "banana"
    b = "banana"
    print(a is b)

This tells us that both ``a`` and ``b`` refer to the same object, and that it
is the second of the two state snapshots that describes the relationship. 
Since strings are *immutable*, Python optimizes resources by making two names
that refer to the same string value refer to the same object.

This is not the case with lists.

.. activecode:: chp09_is2
    
    a = [1,2,3]
    b = [1,2,3]
    print(a is b)

    print(a == b)  

The state snapshot here looks like this:

.. image:: illustrations/ch09/mult_references2.png
   :alt: State snapshot for equal different lists 

``a`` and ``b`` have the same value but do not refer to the same object.

.. index:: aliases

Aliasing
--------

Since variables refer to objects, if we assign one variable to another, both
variables refer to the same object:

.. sourcecode:: python
    
    >>> a = [1, 2, 3]
    >>> b = a
    >>> id(a) == id(b)
    True
    
In this case, the state snapshot looks like this:

.. image:: illustrations/ch09/mult_references3.png
   :alt: State snapshot for multiple references (aliases) to a list 

Because the same list has two different names, ``a`` and ``b``, we say that it
is **aliased**. Changes made with one alias affect the other:

.. activecode:: chp09_is3

    a = [1,2,3]
    b = [1,2,3]

    print(a == b)
    print(a is b)

    b = a
    print(a == b)
    print(a is b)

    b[0] = 5
    print(a)
    

Although this behavior can be useful, it is sometimes unexpected or
undesirable. In general, it is safer to avoid aliasing when you are working
with mutable objects. Of course, for immutable objects, there's no problem.
That's why Python is free to alias strings when it sees an opportunity to
economize.

.. index:: clone

Cloning lists
-------------

If we want to modify a list and also keep a copy of the original, we need to be
able to make a copy of the list itself, not just the reference. This process is
sometimes called **cloning**, to avoid the ambiguity of the word copy.

The easiest way to clone a list is to use the slice operator.

Taking any slice of ``a`` creates a new list. In this case the slice happens to
consist of the whole list.

.. activecode:: chp09_is4

    a = [1,2,3]
    b = [1,2,3]

    print(a == b)
    print(a is b)

    b = a[:]       # make a clone using slice
    print(a == b)
    print(a is b)

    b[0] = 5

    print(a)
    print(b)

Now we are free to make changes to ``b`` without worrying about ``a``:


.. index:: for loop, enumerate

.. index:: for loop

Lists and ``for`` loops
-----------------------

It is also possible to perform **list traversal** using iteration by item as well as iteration by position.


.. activecode:: chp09_03a

    fruits = ["apple","orange","banana","cherry"]

    for fruit in fruits:     # by item
        print(afruit)

It almost reads like natural language: For (every) fruit in (the list of) fruits,
print (the name of the) fruit.

We can also use the indices to access the items in an iterative fashion.

.. activecode:: chp09_03b

    fruits = ["apple","orange","banana","cherry"]

    for position in range(len(fruits)):     # by position
        print(fruits[position])


In this example, each time through the loop, the variable ``position`` is used as an index into the
list, printing the ``position``-eth element. Note that we used ``len`` as the upper bound on the range
so that we can iterate correctly no matter how many items are in the list.




Any list expression can be used in a ``for`` loop:

.. activecode:: chp09_for3
    
    for number in range(20):
        if number % 3 == 0:
            print(number)


This example prints all the multiples of 3 between 0 and 19.

Since lists are mutable, it is often desirable to traverse a list, modifying
each of its elements as you go. The following code squares all the numbers from ``1`` to
``5`` using iteration by position.

.. activecode:: chp09_for4

    numbers = [1, 2, 3, 4, 5]
    print(numbers)

    for i in range(len(numbers)):
        numbers[i] = numbers[i]**2

    print(numbers)

Take a moment to think about ``range(len(numbers))`` until you understand how
it works. We are interested here in both the *value* and its *index* within the
list, so that we can assign a new value to it.


.. index:: parameter

List parameters
---------------

Passing a list as an argument actually passes a reference to the list, not a
copy of the list. Since lists are mutable changes made to the 
elements referenced by the parameter change
the same list that the argument is referencing. 
For example, the function below takes a list as an
argument and multiplies each element in the list by 2:

.. activecode:: chp09_parm1
    
    def doubleStuff(a_list):
        """ Overwrite each element in a_list with double its value. """
        for position in range(len(a_list)):
            a_list[position] = 2 * a_list[position]

    things = [2, 5, 9]
    print(things)
    doubleStuff(things)
    print(things)
    


The parameter ``a_list`` and the variable ``things`` are aliases for the
same object.  

.. image:: illustrations/ch09/mult_references4.png
   :alt: State snapshot for multiple references to a list as a parameter
   
Since the list object is shared by two frames, we drew it between them.
If a function modifies the elements of a list parameter, the caller sees the change.

.. index:: list; append
    
List methods
------------

The dot operator can also be used to access built-in methods of list objects.  
``append`` is a list method which adds the argument passed to it to the end of
the list. Continuing with this example, we show several other list methods.

.. activecode:: chp09_meth1
    
    mylist = []
    mylist.append(5)
    mylist.append(27)
    mylist.append(3)
    mylist.append(12)
    print(mylist)

    mylist.insert(1, 12)
    print(mylist)
    print(mylist.count(12))

    print(mylist.index(3))
    print(mylist.count(5))

    mylist.reverse()
    print(mylist)

    mylist.sort()
    print(mylist)

    mylist.remove(5)
    print(mylist)

Experiment with the list methods shown here.  It is important to note that ``append`` and ``sort`` return ``None``.  This means that re-assigning ``mylist`` to the result of sorting ``mylist`` will result in losing the entire list.

.. activecode:: chp09_meth2
    
    mylist = []
    mylist.append(5)
    mylist.append(27)
    mylist.append(3)
    mylist.append(12)
    print(mylist)

    mylist = mylist.sort()
    print(mylist)

.. index:: side effect, modifier

.. _pure-func-mod:

Pure functions and modifiers
----------------------------

Functions which take lists as arguments and change them during execution are
called **modifiers** and the changes they make are called **side effects**.
A **pure function** does not produce side effects. It communicates with the
calling program only through parameters, which it does not modify, and a return
value. Here is ``doubleStuff`` written as a pure function.

.. activecode:: ch09_mod1
    
    def doubleStuff(a_list):
        """ Return a new list in which contains doubles of the elements in a_list. """
        new_list = []
        for value in a_list:
            new_elem = 2 * value
            new_list.append(new_elem)
        return new_list
    
    things = [2, 5, 9]
    print(doubleStuff(things))
    print(things)

To use the pure function version of ``double_stuff`` to modify ``things``,
you would assign the return value back to ``things``:


.. activecode:: ch09_mod2
    
    def doubleStuff(a_list):
        """ Return a new list in which contains doubles of the elements in a_list. """
        new_list = []
        for value in a_list:
            new_elem = 2 * value
            new_list.append(new_elem)
        return new_list
    
    things = [2, 5, 9]
    print(things)
    things = doubleStuff(things)
    print(things)


Which is better?
----------------

Anything that can be done with modifiers can also be done with pure functions.
In fact, some programming languages only allow pure functions. There is some
evidence that programs that use pure functions are faster to develop and less
error-prone than programs that use modifiers. Nevertheless, modifiers are
convenient at times, and in some cases, functional programs are less efficient.

In general, we recommend that you write pure functions whenever it is
reasonable to do so and resort to modifiers only if there is a compelling
advantage. This approach might be called a *functional programming style*.

Functions that produce lists
----------------------------

The pure version of ``doubleStuff`` above made use of an 
important **pattern** for your toolbox. Whenever you need to
write a function that creates and returns a list, the pattern is
usually::

    initialize a result variable to be an empty list
    loop
       create a new element 
       append it to result
    return the result

Let us show another use of this pattern.  Assuming you already have a function
``is_prime(x)`` that can test if x is prime.  Write a function
to return a list of all prime numbers less than n::

   def primes_upto(n):
       """ Return a list of all prime numbers less than n. """
       result = []
       for i in range(2, n):
           if is_prime(i):
               result.append(i)
       return result

.. index:: nested list, list; nested
       
Nested lists
------------

A nested list is a list that appears as an element in another list. In this
list, the element with index 3 is a nested list.  
If we print(``nested[3]``), we get ``[10, 20]``. To extract an element from the
nested list, we can proceed in two steps.  First, extract the nested list, then extract the item
of interest.  It is also possible to combine those steps using bracket operators that evaluate from
left to right.

.. activecode:: chp09_nest
    
    nested = ["hello", 2.0, 5, [10, 20]]
    innerlist = nested[3]
    print(innerlist)
    item = innerlist[1]
    print(item)

    print(nested[3][1])


.. index:: matrix

Matrices
--------

Nested lists are often used to represent matrices. For example, the matrix::

       1  2  3
       4  5  6
       7  8  9

might be represented as:

.. sourcecode:: python
    
    matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]

``matrix`` is a list with three elements, where each element is a row of the
matrix. We can select an entire row from the matrix in the usual way.
Or, we can extract a single element from the matrix using the double-index form where the first
index is the row and the second index is the column.

.. activecode:: ch09_matrix

    matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
   
    row = matrix[1]
    item = row[2]
    print(item)

    print(matrix[1][2])

The first index selects the row, and the second index selects the column.
Although this way of representing matrices is common, it is not the only
possibility. A small variation is to use a list of columns instead of a list of
rows.

.. index:: Test-driven development, scaffolding


.. index:: strings and lists, split, join

Strings and lists
-----------------

Two of the most useful methods on strings involve lists of
strings. The ``split`` method
breaks a string into a list of words.  By
default, any number of whitespace characters is considered a word boundary.

.. activecode:: ch09_split1
    
    song = "The rain in Spain..."
    wds = song.split()
    print(wds)

An optional argument called a **delimiter** can be used to specify which
characters to use as word boundaries. The following example uses the string
``ai`` as the delimiter:

.. activecode:: ch09_split2
    
    song = "The rain in Spain..."
    wds = song.split('ai')
    print(wds)

Notice that the delimiter doesn't appear in the result.

The inverse of the ``split`` method is ``join``.  You choose a
desired **separator** string, (often called the *glue*) 
and join the list with the glue between each of the elements.

.. activecode:: ch09_join

    wds = ["red", "blue", "green"]
    glue = ';'
    s = glue.join(wds)
    print(s)
    print(wds)

    print("***".join(wds))
    print("".join(wds))


The list that you glue together (``wds`` in this example) is not modified.  Also, 
you can use empty glue or multi-character strings as glue.

    
``list``
--------
    
Python has a built-in type conversion function called 
``list`` that tries to turn whatever you give it
into a list.  

.. activecode:: ch09_list1
    
    xs = list("Crunchy Frog")
    print(xs)

    

 

Glossary
--------

.. glossary::


    aliases
        Multiple variables that contain references to the same object.

    clone
        To create a new object that has the same value as an existing object.
        Copying a reference to an object creates an alias but doesn't clone the
        object.

    delimiter
        A character or string used to indicate where a string should be split.

    element
        One of the values in a list (or other sequence). The bracket operator
        selects elements of a list.

    index
        An integer variable or value that indicates an element of a list.

    list
        A collection of objects, where each object is identified by an index.
        Like other types ``str``, ``int``, ``float``, etc. there is also a
        ``list`` type-converter function that tries to turn its argument into a 
        list. 

    list traversal
        The sequential accessing of each element in a list.

    modifier
        A function which changes its arguments inside the function body. Only
        mutable types can be changed by modifiers.
        
    mutable data type
        A data type in which the elements can be modified. All mutable types
        are compound types. Lists are mutable data types; strings are not.

    nested list
        A list that is an element of another list.

    object
        A thing to which a variable can refer.
        
    pattern
        A sequence of statements, or a style of coding something that has
        general applicability in a number of different situations.  Part of
        becoming a mature Computer Scientist is to learn and establish the
        patterns and algorithms that form your toolkit.  Patterns often 
        correspond to your "mental chunking".   

    promise
        An object that promises to do some work or deliver some values if
        they're eventually needed, but it lazily puts off doing the work immediately.
        Calling ``range`` produces a promise.         

    pure function
        A function which has no side effects. Pure functions only make changes
        to the calling program through their return values.

    sequence
        Any of the data types that consist of an ordered collection of elements, with
        each element identified by an index.
        
    side effect
        A change in the state of a program made by calling a function that is
        not a result of reading the return value from the function. Side
        effects can only be produced by modifiers.

    step size
        The interval between successive elements of a linear sequence. The
        third (and optional argument) to the ``range`` function is called the
        step size.  If not specified, it defaults to 1.

    test-driven development (TDD)
        A software development practice which arrives at a desired feature
        through a series of small, iterative steps motivated by automated tests
        which are *written first* that express increasing refinements of the
        desired feature.  (see the Wikipedia article on `Test-driven
        development <http://en.wikipedia.org/wiki/Test_driven_development>`__
        for more information.)

Exercises
---------


#. What is the Python interpreter's response to the following?

   .. sourcecode:: python
    
       >>> list(range(10, 0, -2))

   The three arguments to the *range* function are *start*, *stop*, and *step*, 
   respectively. In this example, ``start`` is greater than ``stop``.  What
   happens if ``start < stop`` and ``step < 0``? Write a rule for the
   relationships among ``start``, ``stop``, and ``step``.
   
#. Consider this fragment of code::

        import turtle
        
        tess = turtle.Turtle()
        alex = tess
        alex.color("hotpink")
   
   Does this fragment create one or two turtle instances?  Does setting
   the colour of ``alex`` also change the colour of ``tess``?  Explain in detail.
   
#. Draw a state snapshot for ``a`` and ``b`` before and after the third line of
   the following python code is executed:

   .. sourcecode:: python
    
       a = [1, 2, 3]
       b = a[:]
       b[0] = 5

#. What will be the output of the following program?

   .. sourcecode:: python
    
       this = ['I', 'am', 'not', 'a', 'crook']
       that = ['I', 'am', 'not', 'a', 'crook']
       print("Test 1: {0}".format(this is that))
       that = this
       print("Test 2: {0}".format(this == that))

   Provide a *detailed* explaination of the results.
     
#. Lists can be used to represent mathematical *vectors*.  In this exercise
   and several that follow you will write functions to perform standard
   operations on vectors.  Create a script named ``vectors.py`` and 
   write Python code to pass the tests in each case.

   Write a function ``add_vectors(u, v)`` that takes two lists of numbers of
   the same length, and returns a new list containing the sums of the
   corresponding elements of each::
   
       test(add_vectors([1, 1], [1, 1]), [2, 2])
       test(add_vectors([1, 2], [1, 4]), [2, 6])
       test(add_vectors([1, 2, 1], [1, 4, 3]), [2, 6, 4])
 
#. Write a function ``scalar_mult(s, v)`` that takes a number, ``s``, and a
   list, ``v`` and returns the `scalar multiple
   <http://en.wikipedia.org/wiki/Scalar_multiple>`__ of ``v`` by ``s``. ::

        test(scalar_mult(5, [1, 2]), [5, 10])
        test(scalar_mult(3, [1, 0, -1]), [3, 0, -3])
        test(scalar_mult(7, [3, 0, 5, 11, 2]), [21, 0, 35, 77, 14])

#. Write a function ``dot_product(u, v)`` that takes two lists of numbers of
   the same length, and returns the sum of the products of the corresponding
   elements of each (the `dot_product
   <http://en.wikipedia.org/wiki/Dot_product>`__).

   .. sourcecode:: python
    
      test(dot_product([1, 1], [1, 1]),  2)
      test(dot_product([1, 2], [1, 4]),  9)
      test(dot_product([1, 2, 1], [1, 4, 3]), 12)
      
#. *Extra challenge for the mathematically inclined*: Write a function
   ``cross_product(u, v)`` that takes two lists of numbers of length 3 and
   returns their
   `cross product <http://en.wikipedia.org/wiki/Cross_product>`__.  You should
   write your own tests and use the test driven development process
   described in the chapter.      

#. Create a new module named ``matrices.py`` and add the following two
   functions introduced in the section on test-driven development:
  
   .. sourcecode:: python
       
        m = [[0, 0], [0, 0]]
        q = add_row(m)
        test(q, [[0, 0], [0, 0], [0, 0]])
        n = [[3, 2, 5], [1, 4, 7]]
        w = add_row(n)
        test(w, [[3, 2, 5], [1, 4, 7], [0, 0, 0]])
        test(n, [[3, 2, 5], [1, 4, 7]])
        n[0][0] = 42
        test(w, [[3, 2, 5], [1, 4, 7], [0, 0, 0]])
    
        m = [[0, 0], [0, 0]]
        q = add_column(m)
        test(q, [[0, 0, 0], [0, 0, 0]])
        n = [[3, 2], [5, 1], [4, 7]]
        w = add_column(n)
        test(w, [[3, 2, 0], [5, 1, 0], [4, 7, 0]])
        test( n, [[3, 2], [5, 1], [4, 7]])


   Your new functions should pass the tests. Note that the last test in
   each case assures that ``add_row`` and ``add_column`` are pure
   functions. ( *hint:* Python has a ``copy`` module with a function named
   ``deepcopy`` that could make your task easier here. We will talk more about
   ``deepcopy`` in chapter 13, but google python copy module if you would like
   to try it now.)
   
#. Write a function ``add_matrices(m1, m2)`` that adds ``m1`` and ``m2`` and
   returns a new matrix containing their sum. You can assume that ``m1`` and
   ``m2`` are the same size. You add two matrices by adding their corresponding 
   values::

     a = [[1, 2], [3, 4]]
     b = [[2, 2], [2, 2]]
     x = add_matrices(a, b)
     test(x, [[3, 4], [5, 6]])
     c = [[8, 2], [3, 4], [5, 7]]
     d = [[3, 2], [9, 2], [10, 12]]
     y = add_matrices(c, d)
     test(y, [[11, 4], [12, 6], [15, 19]])
     test(c, [[8, 2], [3, 4], [5, 7]])
     test(d, [[3, 2], [9, 2], [10, 12]])
          
   The last two tests confirm that ``add_matrices`` is a pure
   function.
   
#. Write a pure function ``scalar_mult(s, m)`` that multiplies a matrix, ``m``, by a 
   scalar, ``s``::

        a = [[1, 2], [3, 4]]
        x = scalar_mult(3, a)
        test(x, [[3, 6], [9, 12]])
        b = [[3, 5, 7], [1, 1, 1], [0, 2, 0], [2, 2, 3]]
        y = scalar_mult(10, b)
        test(y, [[30, 50, 70], [10, 10, 10], [0, 20, 0], [20, 20, 30]])
        test(b, [[3, 5, 7], [1, 1, 1], [0, 2, 0], [2, 2, 3]])

#.  Let's create functions to make these tests pass::

       test(row_times_column([[1, 2], [3, 4]], 0, [[5, 6], [7, 8]], 0), 19)
       test(row_times_column([[1, 2], [3, 4]], 0, [[5, 6], [7, 8]], 1), 22)
       test(row_times_column([[1, 2], [3, 4]], 1, [[5, 6], [7, 8]], 0), 43)
       test(row_times_column([[1, 2], [3, 4]], 1, [[5, 6], [7, 8]], 1), 50)

       test(matrix_mult([[1, 2], [3,  4]], [[5, 6], [7, 8]]), [[19, 22], [43, 50]])
       test(matrix_mult([[1, 2, 3], [4,  5, 6]], [[7, 8], [9, 1], [2, 3]]), 
                     [[31, 19], [85, 55]])
       test(matrix_mult([[7, 8], [9, 1], [2, 3]], [[1, 2, 3], [4, 5, 6]]),
             [[39, 54, 69], [13, 23, 33], [14, 19, 24]])

#. Write functions to pass these tests: 

   .. sourcecode:: python

        test(only_evens([1, 3, 4, 6, 7, 8]), [4, 6, 8])
        test(only_evens([2, 4, 6, 8, 10, 11, 0]), [2, 4, 6, 8, 10, 0])
        test(only_evens([1, 3, 5, 7, 9, 11]), [])
        test(only_evens([4, 0, -1, 2, 6, 7, -4]), [4, 0, 2, 6, -4])
        nums = [1, 2, 3, 4]
        test(only_evens(nums), [2, 4])
        test(nums, [1, 2, 3, 4])

        test(only_odds([1, 3, 4, 6, 7, 8]), [1, 3, 7])
        test(only_odds([2, 4, 6, 8, 10, 11, 0]), [11])
        test(only_odds([1, 3, 5, 7, 9, 11]), [1, 3, 5, 7, 9, 11])
        test(only_odds([4, 0, -1, 2, 6, 7, -4]), [-1, 7])
        nums = [1, 2, 3, 4]
        test(only_odds(nums), [1, 3])
        test(nums, [1, 2, 3, 4])
   
#. Add a function ``multiples_of(num, numlist)`` to ``numberlists.py`` that
   takes an integer (``num``), and a list of integers (``numlist``) as
   arguments and returns a list of those integers in ``numlist`` that are
   multiples of ``num``.  Add your own tests and use TDD to develope this
   function.             
             
             
             
#. Describe the relationship between ``' '.join(song.split())`` and
   ``song`` in the fragment of code below. 
   Are they the same for all strings assigned to ``song``? 
   When would they be different? ::
   
        song = "The rain in Spain..."
   
#. Write a function ``replace(s, old, new)`` that replaces all occurences of
   ``old`` with ``new`` in a string ``s``::

      test(replace('Mississippi', 'i', 'I'), 'MIssIssIppI')
      
      s = 'I love spom!  Spom is my favorite food.  Spom, spom, spom, yum!'
      test(replace(s, 'om', 'am'),
             'I love spam!  Spam is my favorite food.  Spam, spam, spam, yum!')
    
      test(replace(s, 'o', 'a'),
             'I lave spam!  Spam is my favarite faad.  Spam, spam, spam, yum!')

   *Hint*: use the ``split`` and ``join`` methods.
