

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Graphs &mdash; Problem Solving with Algorithms and Data Structures 3.0 documentation</title>
    
    <link rel="stylesheet" href="_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/video.css" type="text/css" />
    <link rel="stylesheet" href="_static/edu-python.css" type="text/css" />
    <link rel="stylesheet" href="_static/codemirror.css" type="text/css" />
    <link rel="stylesheet" href="_static/theme/default.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '3.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/simplemodal.js"></script>
    <script type="text/javascript" src="_static/jquery.textarea.js"></script>
    <script type="text/javascript" src="_static/edu-python.js"></script>
    <script type="text/javascript" src="_static/bookfuncs.js"></script>
    <script type="text/javascript" src="_static/codemirror.js"></script>
    <script type="text/javascript" src="_static/python.js"></script>
    <script type="text/javascript" src="_static/skulpt.js"></script>
    <script type="text/javascript" src="_static/builtin.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="Problem Solving with Algorithms and Data Structures 3.0 documentation" href="index.html" />
    <link rel="prev" title="Trees" href="trees.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="trees.html" title="Trees"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">Problem Solving with Algorithms and Data Structures 3.0 documentation</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Graphs</a><ul>
<li><a class="reference internal" href="#objectives">Objectives</a></li>
<li><a class="reference internal" href="#vocabulary-and-definitions">Vocabulary and Definitions</a></li>
<li><a class="reference internal" href="#the-graph-abstract-data-type">The Graph Abstract Data Type</a><ul>
<li><a class="reference internal" href="#an-adjacency-matrix">An Adjacency Matrix</a></li>
<li><a class="reference internal" href="#an-adjacency-list">An Adjacency List</a></li>
<li><a class="reference internal" href="#implementation">Implementation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#breadth-first-search">Breadth First Search</a><ul>
<li><a class="reference internal" href="#the-word-ladder-problem">The Word Ladder Problem</a></li>
<li><a class="reference internal" href="#building-the-word-ladder-graph">Building the Word Ladder Graph</a></li>
<li><a class="reference internal" href="#implementing-breadth-first-search">Implementing Breadth First Search</a></li>
<li><a class="reference internal" href="#breadth-first-search-analysis">Breadth First Search Analysis</a></li>
</ul>
</li>
<li><a class="reference internal" href="#depth-first-search">Depth First Search</a><ul>
<li><a class="reference internal" href="#the-knights-tour-problem">The Knight’s Tour Problem</a></li>
<li><a class="reference internal" href="#building-the-knights-tour-graph">Building the Knight’s Tour Graph</a></li>
<li><a class="reference internal" href="#implementing-knights-tour">Implementing Knight’s Tour</a></li>
<li><a class="reference internal" href="#knights-tour-analysis">Knight’s Tour Analysis</a></li>
<li><a class="reference internal" href="#general-depth-first-search">General Depth First Search</a></li>
<li><a class="reference internal" href="#depth-first-search-analysis">Depth First Search Analysis</a></li>
</ul>
</li>
<li><a class="reference internal" href="#topological-sorting">Topological Sorting</a></li>
<li><a class="reference internal" href="#strongly-connected-components">Strongly Connected Components</a></li>
<li><a class="reference internal" href="#shortest-path-problems">Shortest Path Problems</a><ul>
<li><a class="reference internal" href="#dijkstras-algorithm">Dijkstra’s Algorithm</a></li>
<li><a class="reference internal" href="#analysis-of-dijkstras-algorithm">Analysis of Dijkstra’s Algorithm</a></li>
<li><a class="reference internal" href="#prims-spanning-tree-algorithm">Prim’s Spanning Tree Algorithm</a></li>
</ul>
</li>
<li><a class="reference internal" href="#summary">Summary</a></li>
<li><a class="reference internal" href="#key-terms">Key Terms</a></li>
<li><a class="reference internal" href="#discussion-questions">Discussion Questions</a></li>
<li><a class="reference internal" href="#programming-exercises">Programming Exercises</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="trees.html"
                        title="previous chapter">Trees</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/graphs.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="graphs">
<h1>Graphs<a class="headerlink" href="#graphs" title="Permalink to this headline">¶</a></h1>
<div class="section" id="objectives">
<h2>Objectives<a class="headerlink" href="#objectives" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>To learn what a graph is and how it is used.</li>
<li>To implement the <strong>graph</strong> abstract data type using multiple internal
representations.</li>
<li>To see how graphs can be used to solve a wide variety of problems</li>
</ul>
<p>In this chapter we will study graphs. Graphs are a more general
structure than the trees we studied in the last chapter; in fact you can
think of a tree as a special kind of graph. Graphs can be used to
represent many interesting things about our world, including systems of
roads, airline flights from city to city, how the Internet is connected,
or even the sequence of classes you must take to complete a major in
computer science. We will see in this chapter that once we have a good
representation for a problem, we can use some standard graph algorithms
to solve what otherwise might seem to be a very difficult problem.</p>
<p>While it is relatively easy for humans to look at a road map and
understand the relationships between different places, a computer has no
such knowledge. However, we can also think of a road map as a graph.
When we do so we can have our computer do interesting things for us. If
you have ever used one of the Internet map sites, you know that a
computer can find the shortest, quickest, or easiest path from one place
to another.</p>
<p>As a student of computer science you may wonder about the courses you
must take in order to get a major. A graph is good way to represent the
prerequisites and other interdependencies among courses.
<a class="reference internal" href="#fig1"><em>Figure 1</em></a> shows another graph. This one represents the courses
and the order in which they must be taken to complete a major in
computer science at Luther College.</p>
<blockquote>
<div><div class="figure align-center" id="fig1">
<img alt="image" src="_images/CS-Prereqs.png" />
<p class="caption">Figure 1: Prerequisites for a Computer Science Major</p>
</div>
</div></blockquote>
</div>
<div class="section" id="vocabulary-and-definitions">
<h2>Vocabulary and Definitions<a class="headerlink" href="#vocabulary-and-definitions" title="Permalink to this headline">¶</a></h2>
<p>Now that we have looked at some examples of graphs, we will more
formally define a graph and its components. We already know some of
these terms from our discussion of trees.</p>
<dl class="docutils">
<dt>Vertex</dt>
<dd>A vertex (also called a “node”) is a fundamental part of a graph. It
can have a name, which we will call the “key.” A vertex may also
have additional information. We will call this additional
information the “payload.”</dd>
<dt>Edge</dt>
<dd>An edge (also called an “arc”) is another fundamental part of a
graph. An edge connects two vertices to show that there is a
relationship between them. Edges may be one-way or two-way. If the
edges in a graph are all one-way, we say that the graph is a
<strong>directed graph</strong>, or a <strong>digraph</strong>. The class prerequisites graph
shown above is clearly a digraph since you must take some classes
before others.</dd>
<dt>Weight</dt>
<dd>Edges may be weighted to show that there is a cost to go from one
vertex to another. For example in a graph of roads that connect one
city to another, the weight on the edge might represent the distance
between the two cities.</dd>
</dl>
<p>With those definitions in hand we can formally define a graph. A graph
can be represented by <span class="math">\(G\)</span> where <span class="math">\(G =(V,E)\)</span>. For the
graph <span class="math">\(G\)</span>, <span class="math">\(V\)</span> is a set of vertices and <span class="math">\(E\)</span> is a
set of edges. Each edge is a tuple <span class="math">\((v,w)\)</span> where
<span class="math">\(w,v \in V\)</span>. We can add a third component to the edge tuple to
represent a weight. A subgraph <span class="math">\(s\)</span> is a set of edges <span class="math">\(e\)</span>
and vertices <span class="math">\(v\)</span> such that <span class="math">\(e \subset E\)</span> and
<span class="math">\(v \subset V\)</span>.</p>
<p><a class="reference internal" href="#fig-dgsimple"><em>Figure&nbsp; 2</em></a> shows another example of a simple weighted
digraph. Formally we can represent this graph as the set of six
vertices:</p>
<div class="math">
\[V = \left\{ V0,V1,V2,V3,V4,V5 \right\}\]</div>
<p>and the set of nine edges:</p>
<div class="math">
\[\begin{split}E = \left\{ \begin{array}{l}(v0,v1,5), (v1,v2,4), (v2,v3,9), (v3,v4,7), (v4,v0,1), \\
             (v0,v5,2),(v5,v4,8),(v3,v5,3),(v5,v2,1)
             \end{array} \right\}\end{split}\]</div>
<div class="figure align-center" id="fig-dgsimple">
<img alt="image" src="_images/digraph.png" />
</div>
<p>The example graph in <a class="reference internal" href="#fig-dgsimple"><em>Figure x</em></a> helps illustrate two other
key graph terms:</p>
<dl class="docutils">
<dt>Path</dt>
<dd>A path in a graph is a sequence of vertices that are connected by
edges. Formally we would define a path as
<span class="math">\(w_1, w_2, ..., w_n\)</span> such that
<span class="math">\((w_i, w_{i+1}) \in E\)</span> for all <span class="math">\(1 \le i \le n-1\)</span>.
The unweighted path length is the number of edges in the path,
specifically <span class="math">\(n-1\)</span>. The weighted path length is the sum of
the weights of all the edges in the path. For example in
<a class="reference internal" href="#fig-dgsimple"><em>Figure x</em></a> the path from <span class="math">\(V3\)</span> to <span class="math">\(V1\)</span> is
the sequence of vertices <span class="math">\((V3,V4,V0,V1)\)</span>. The edges are
<span class="math">\(\left\{(v3,v4,7),(v4,v0,1),(v0,v1,5) \right\}\)</span>.</dd>
<dt>Cycle</dt>
<dd>A cycle in a directed graph is a path that starts and ends at the
same vertex. For example, in <a class="reference internal" href="#fig-dgsimple"><em>Figure x</em></a> the path
<span class="math">\((V5,V2,V3,V5)\)</span> is a cycle. A graph with no cycles is called
an <strong>acyclic graph</strong>. A directed graph with no cycles is called a
<strong>directed acyclic graph</strong> or a <strong>DAG</strong>. We will see that we can
solve several important problems if the problem can be represented
as a DAG.</dd>
</dl>
</div>
<div class="section" id="the-graph-abstract-data-type">
<h2>The Graph Abstract Data Type<a class="headerlink" href="#the-graph-abstract-data-type" title="Permalink to this headline">¶</a></h2>
<p>The graph abstract data type (ADT) is defined as follows:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">Graph()</span></tt> creates a new, empty graph.</li>
<li><tt class="docutils literal"><span class="pre">addVertex(vert)</span></tt> adds an instance of <tt class="docutils literal"><span class="pre">Vertex</span></tt> to the graph.</li>
<li><tt class="docutils literal"><span class="pre">addEdge(fromVert,</span> <span class="pre">toVert)</span></tt> Adds a new, directed edge to the graph
that connects two vertices.</li>
<li><tt class="docutils literal"><span class="pre">addEdge(fromVert,</span> <span class="pre">toVert,</span> <span class="pre">weight)</span></tt> Adds a new, weighted, directed
edge to the graph that connects two vertices.</li>
<li><tt class="docutils literal"><span class="pre">getVertex(vertKey)</span></tt> finds the vertex in the graph named
<tt class="docutils literal"><span class="pre">vertKey</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">getVertices()</span></tt> returns the list of all vertices in the graph.</li>
<li><tt class="docutils literal"><span class="pre">in</span></tt> returns <tt class="docutils literal"><span class="pre">True</span></tt> for a statement of the form
<tt class="docutils literal"><span class="pre">vertex</span> <span class="pre">in</span> <span class="pre">graph</span></tt>, if the given vertex is in the graph, <tt class="docutils literal"><span class="pre">False</span></tt>
otherwise.</li>
</ul>
<p>Beginning with the formal definition for a graph there are several ways
we can implement the graph ADT in Python. We will see that there are
trade-offs in using different representations to implement the ADT
described above. There are two well-known implementations of a graph,
the <strong>adjacency matrix</strong> and the <strong>adjacency list</strong>. We will explain
both of these options, and then implement one as a Python class.</p>
<div class="section" id="an-adjacency-matrix">
<h3>An Adjacency Matrix<a class="headerlink" href="#an-adjacency-matrix" title="Permalink to this headline">¶</a></h3>
<p>One of the easiest ways to implement a graph is to use a two-dimensional
matrix. In this matrix implementation, each of the rows and columns
represent a vertex in the graph. The value that is stored in the cell at
the intersection of row <span class="math">\(v\)</span> and column <span class="math">\(w\)</span> indicates if
there is an edge from vertex <span class="math">\(v\)</span> to vertex <span class="math">\(w\)</span>. When two
vertices are connected by an edge, we say that they are <strong>adjacent</strong>.
<a class="reference internal" href="#fig-adjmat"><em>Figure 1</em></a> illustrates the adjacency matrix for the graph in
<a class="reference internal" href="#fig-dgsimple"><em>Figure x</em></a>. A value in a cell represents the weight of the
edge from vertex <span class="math">\(v\)</span> to vertex <span class="math">\(w\)</span>.</p>
<blockquote>
<div><div class="figure align-center" id="fig-adjmat">
<img alt="image" src="_images/adjMat.png" />
<p class="caption">{An Adjacency Matrix Representation for a Graph}</p>
</div>
</div></blockquote>
<p>The advantage of the adjacency matrix is that it is simple, and for
small graphs it is easy to see which nodes are connected to other nodes.
However, notice that most of the cells in the matrix are empty. Because
most of the cells are empty we say that this matrix is “sparse.” A
matrix is not a very efficient way to store sparse data. In fact, in
Python you must go out of your way to even create a matrix structure
like the one in <a class="reference internal" href="#fig-adjmat"><em>Figure 1</em></a>.</p>
<p>The adjacency matrix is a good implementation for a graph when the
number of edges is large. But what do we mean by large? How many edges
would be needed to fill the matrix? Since there is one row and one
column for every vertex in the graph, the number of edges required to
fill the matrix is <span class="math">\(|V|^2\)</span>. A matrix is full when every vertex
is connected to every other vertex. There are few real problems that
approach this sort of connectivity. The problems we will look at in this
chapter all involve graphs that are sparsely connected.</p>
</div>
<div class="section" id="an-adjacency-list">
<h3>An Adjacency List<a class="headerlink" href="#an-adjacency-list" title="Permalink to this headline">¶</a></h3>
<p>A more space-efficient way to implement a sparsely connected graph is to
use an adjacency list. In an adjacency list implementation we keep a
master list of all the vertices in the Graph object and then each vertex
object in the graph maintains a list of the other vertices that it is
connected to. In our implementation of the <tt class="docutils literal"><span class="pre">Vertex</span></tt> class we will use
a dictionary rather than a list where the dictionary keys are the
vertices, and the values are the weights. <a class="reference internal" href="#fig-adjlist"><em>Figure 2</em></a>
illustrates the adjacency list representation for the graph in
<a class="reference internal" href="#fig-dgsimple"><em>Figure x</em></a>.</p>
<blockquote>
<div><div class="figure align-center" id="fig-adjlist">
<img alt="image" src="_images/adjlist.png" />
<p class="caption">{An Adjacency List Representation of a Graph}</p>
</div>
</div></blockquote>
<p>The advantage of the adjacency list implementation is that it allows us
to compactly represent a sparse graph. The adjacency list also allows us
to easily find all the links that are directly connected to a particular
vertex.</p>
</div>
<div class="section" id="implementation">
<h3>Implementation<a class="headerlink" href="#implementation" title="Permalink to this headline">¶</a></h3>
<p>Using dictionaries, it is easy to implement the adjacency list in
Python. In our implementation of the Graph abstract data type we will
create two classes, <tt class="docutils literal"><span class="pre">Graph</span></tt>, which holds the master list of vertices,
and <tt class="docutils literal"><span class="pre">Vertex</span></tt>, which will represent each vertex in the graph.</p>
<p>Each <tt class="docutils literal"><span class="pre">Vertex</span></tt> uses a dictionary to keep track of the vertices to which
it is connected, and the weight of each edge. This dictionary is called
<tt class="docutils literal"><span class="pre">connectedTo</span></tt>. Listing&nbsp;{lst:vertex} shows the code for the <tt class="docutils literal"><span class="pre">Vertex</span></tt>
class. The constructor simply initializes the <tt class="docutils literal"><span class="pre">id</span></tt>, which will
typically be a string, and the <tt class="docutils literal"><span class="pre">connectedTo</span></tt> dictionary. The
<tt class="docutils literal"><span class="pre">addNeighbor</span></tt> method is used add a connection from this vertex to
another. The <tt class="docutils literal"><span class="pre">getConnections</span></tt> method returns all of the vertices in
the adjacency list, as represented by the <tt class="docutils literal"><span class="pre">connectedTo</span></tt> instance
variable. The <tt class="docutils literal"><span class="pre">getWeight</span></tt> method returns the weight of the edge from
this vertex to the vertex passed as a parameter.</p>
<div class="highlight-python"><pre>class Vertex:
    def __init__(self,key):
        self.id = key
        self.connectedTo = {}

    def addNeighbor(self,nbr,weight=0):
        self.connectedTo[nbr] = weight

    def __str__(self):
        return str(self.id) + ' connectedTo: '
               + str([x.id for x in self.connectedTo])

    def getConnections(self):
        return self.connectedTo.keys()

    def getId(self):
        return self.id

    def getWeight(self,nbr):
        return self.connectedTo[nbr]</pre>
</div>
<p>The <tt class="docutils literal"><span class="pre">Graph</span></tt> class, shown in Listing&nbsp;{lst:graph}, contains a dictionary
that maps vertex names to vertex objects. In <a class="reference internal" href="#fig-adjlist"><em>Figure 2</em></a> this
dictionary object is represented by the shaded gray box. <tt class="docutils literal"><span class="pre">Graph</span></tt> also
provides methods for adding vertices to a graph and connecting one
vertex to another. The <tt class="docutils literal"><span class="pre">getVertices</span></tt> method returns the names of all
of the vertices in the graph. In addition, we have implemented the
{__iter__} method to make it easy to iterate over all the vertex
objects in a particular graph. Together, the two methods allow you to
iterate over the vertices in a graph by name, or by the objects
themselves.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Graph</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vertList</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">numVertices</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">addVertex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">key</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">numVertices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">numVertices</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">newVertex</span> <span class="o">=</span> <span class="n">Vertex</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vertList</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">newVertex</span>
        <span class="k">return</span> <span class="n">newVertex</span>

    <span class="k">def</span> <span class="nf">getVertex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">n</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertList</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertList</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">n</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertList</span>

    <span class="k">def</span> <span class="nf">addEdge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">f</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">cost</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">f</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertList</span><span class="p">:</span>
            <span class="n">nv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">addVertex</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">t</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertList</span><span class="p">:</span>
            <span class="n">nv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">addVertex</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vertList</span><span class="p">[</span><span class="n">f</span><span class="p">]</span><span class="o">.</span><span class="n">addNeighbor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertList</span><span class="p">[</span><span class="n">t</span><span class="p">],</span>
                                         <span class="n">cost</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">getVertices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertList</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertList</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
</pre></div>
</div>
<p>Using the <tt class="docutils literal"><span class="pre">Graph</span></tt> and <tt class="docutils literal"><span class="pre">Vertex</span></tt> classes just defined, the following
Python session creates the graph in <a class="reference internal" href="#fig-dgsimple"><em>Figure x</em></a>. First we
create six vertices numbered 0 through 5. Then we display the vertex
dictionary. Notice that for each key 0 through 5 we have created an
instance of a <tt class="docutils literal"><span class="pre">Vertex</span></tt>. Next, we add the edges that connect the
vertices together. Finally, a nested loop verifies that each edge in the
graph is properly stored. You should check the output of the edge list
at the end of this session against <a class="reference internal" href="#fig-dgsimple"><em>Figure x</em></a>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">):</span>
<span class="gp">... </span>   <span class="n">g</span><span class="o">.</span><span class="n">addVertex</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">vertList</span>
<span class="go">{0: &lt;adjGraph.Vertex instance at 0x41e18&gt;,</span>
<span class="go"> 1: &lt;adjGraph.Vertex instance at 0x7f2b0&gt;,</span>
<span class="go"> 2: &lt;adjGraph.Vertex instance at 0x7f288&gt;,</span>
<span class="go"> 3: &lt;adjGraph.Vertex instance at 0x7f350&gt;,</span>
<span class="go"> 4: &lt;adjGraph.Vertex instance at 0x7f328&gt;,</span>
<span class="go"> 5: &lt;adjGraph.Vertex instance at 0x7f300&gt;}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">addEdge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">addEdge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">addEdge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">addEdge</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">9</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">addEdge</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">addEdge</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">addEdge</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">addEdge</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">addEdge</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">g</span><span class="p">:</span>
<span class="gp">... </span>   <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">v</span><span class="o">.</span><span class="n">getConnections</span><span class="p">():</span>
<span class="gp">... </span>       <span class="k">print</span><span class="p">(</span><span class="s">&quot;( </span><span class="si">%s</span><span class="s"> , </span><span class="si">%s</span><span class="s"> )&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">getId</span><span class="p">(),</span> <span class="n">w</span><span class="o">.</span><span class="n">getId</span><span class="p">()))</span>
<span class="gp">...</span>
<span class="go">( 0 , 5 )</span>
<span class="go">( 0 , 1 )</span>
<span class="go">( 1 , 2 )</span>
<span class="go">( 2 , 3 )</span>
<span class="go">( 3 , 4 )</span>
<span class="go">( 3 , 5 )</span>
<span class="go">( 4 , 0 )</span>
<span class="go">( 5 , 4 )</span>
<span class="go">( 5 , 2 )</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="breadth-first-search">
<h2>Breadth First Search<a class="headerlink" href="#breadth-first-search" title="Permalink to this headline">¶</a></h2>
<div class="section" id="the-word-ladder-problem">
<h3>The Word Ladder Problem<a class="headerlink" href="#the-word-ladder-problem" title="Permalink to this headline">¶</a></h3>
<p>To begin our study of graph algorithms let’s consider the following
puzzle called a word ladder. Transform the word “FOOL” into the word
“SAGE”. In a word ladder puzzle you must make the change occur gradually
by changing one letter at a time. At each step you must transform one
word into another word, you are not allowed to transform a word into a
non-word. The word ladder puzzle was invented in 1878 by Lewis Carroll,
the author of <em>Alice in Wonderland</em>. The following sequence of words
shows one possible solution to the problem posed above.</p>
<table border="1" class="docutils">
<colgroup>
<col width="75%" />
<col width="25%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>FOOL</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td>POOL</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td>POLL</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td>POLE</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td>PALE</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td>SALE</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td>SAGE</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<p>There are many variations of the word ladder puzzle. For example you
might be given a particular number of steps in which to accomplish the
transformation, or you might need to use a particular word. In this
section we are interested in figuring out the smallest number of
transformations needed to turn the starting word into the ending word.</p>
<p>Not surprisingly, since this chapter is on graphs, we can solve this
problem using a graph algorithm. Here is an outline of where we are
going:</p>
<ul class="simple">
<li>Represent the relationships between the words as a graph.</li>
<li>Use the graph algorithm known as breadth first search to find an
efficient path from the starting word to the ending word.</li>
</ul>
</div>
<div class="section" id="building-the-word-ladder-graph">
<h3>Building the Word Ladder Graph<a class="headerlink" href="#building-the-word-ladder-graph" title="Permalink to this headline">¶</a></h3>
<p>Our first problem is to figure out how to turn a large collection of
words into a graph. What we would like is to have an edge from one word
to another if the two words are only different by a single letter. If we
can create such a graph, then any path from one word to another is a
solution to the word ladder puzzle. <a class="reference internal" href="#fig-wordladder"><em>Figure 3</em></a> shows a
small graph of some words that solve the FOOL to SAGE word ladder
problem. Notice that the graph is an undirected graph and that the edges
are unweighted.</p>
<blockquote>
<div><div class="figure align-center" id="fig-wordladder">
<img alt="image" src="_images/wordgraph.png" />
<p class="caption">{A Small Word Ladder Graph}</p>
</div>
</div></blockquote>
<p>We could use several different approaches to create the graph we need to
solve this problem. Let’s start with the assumption that we have a list
of words that are all the same length. As a starting point, we can
create a vertex in the graph for every word in the list. To figure out
how to connect the words, we could compare each word in the list with
every other. When we compare we are looking to see how many letters are
different. If the two words in question are different by only one
letter, we can create an edge between them in the graph. For a small set
of words that approach would work fine; however let’s suppose we have a
list of 5,110 words. Roughly speaking, comparing one word to every other
word on the list is an <span class="math">\(O(n^2)\)</span> algorithm. For 5,110 words,
<span class="math">\(n^2\)</span> is more than 26&nbsp;million comparisons.</p>
<p>We can do much better by using the following approach. Suppose that we
have a huge number of buckets, each of them with a four-letter word on
the outside, except that one of the letters in the label has been
replaced by an underscore. For example, consider
<em class="xref std std-ref">Figure 4</em>, we might have a bucket labeled “pop_.” As we
process each word in our list we compare the word with each bucket,
using the ‘_’ as a wildcard, so both “pope” and “pops” would match
“pop_.” Every time we find a matching bucket, we put our word in that
bucket. Once we have all the words in the appropriate buckets we know
that all the words in the bucket must be connected.</p>
<blockquote>
<div><img alt="image" src="_images/wordbuckets.png" /> {Word Buckets for Words That are Different by One Letter}
.. _fig_wordbucket:</div></blockquote>
<p>In Python, we can implement the scheme we have just described by using a
dictionary. The labels on the buckets we have just described are the
keys in our dictionary. The value stored for that key is a list of
words. Once we have the dictionary built we can create the graph. We
start our graph by creating a vertex for each word in the graph. Then we
create edges between all the vertices we find for words found under the
same key in the dictionary. Listing&nbsp;{lst:laddergraph} shows the Python
code required to build the graph.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">pythonds.graphs</span> <span class="kn">import</span> <span class="n">Graph</span>
<span class="k">def</span> <span class="nf">buildGraph</span><span class="p">(</span><span class="n">wordFile</span><span class="p">):</span>
    <span class="n">d</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">()</span>
    <span class="n">wfile</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">wordFile</span><span class="p">,</span><span class="s">&#39;r&#39;</span><span class="p">)</span>
    <span class="c"># create buckets of words that differ by one letter</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">wfile</span><span class="p">:</span>
        <span class="n">word</span> <span class="o">=</span> <span class="n">line</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">word</span><span class="p">)):</span>
            <span class="n">bucket</span> <span class="o">=</span> <span class="n">word</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="s">&#39;_&#39;</span> <span class="o">+</span> <span class="n">word</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
            <span class="k">if</span> <span class="n">bucket</span> <span class="ow">in</span> <span class="n">d</span><span class="p">:</span>
                <span class="n">d</span><span class="p">[</span><span class="n">bucket</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">word</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">d</span><span class="p">[</span><span class="n">bucket</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">word</span><span class="p">]</span>
    <span class="c"># add vertices and edges for words in the same bucket</span>
    <span class="k">for</span> <span class="n">bucket</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">word1</span> <span class="ow">in</span> <span class="n">d</span><span class="p">[</span><span class="n">bucket</span><span class="p">]:</span>
            <span class="k">for</span> <span class="n">word2</span> <span class="ow">in</span> <span class="n">d</span><span class="p">[</span><span class="n">bucket</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">word1</span> <span class="o">!=</span> <span class="n">word2</span><span class="p">:</span>
                    <span class="n">g</span><span class="o">.</span><span class="n">addEdge</span><span class="p">(</span><span class="n">word1</span><span class="p">,</span><span class="n">word2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">g</span>
</pre></div>
</div>
<p>Since this is our first real-world graph problem, you might be wondering
how sparse is the graph? The list of four-letter words we have for this
problem is 5,110 words long. If we were to use an adjacency matrix, the
matrix would have 5,110 * 5,110 = 26,112,100 cells. The graph
constructed by the <tt class="docutils literal"><span class="pre">buildGraph</span></tt> function has exactly 53,286 edges, so
the matrix would have only 0.20% of the cells filled! That is a very
sparse matrix indeed.</p>
</div>
<div class="section" id="implementing-breadth-first-search">
<h3>Implementing Breadth First Search<a class="headerlink" href="#implementing-breadth-first-search" title="Permalink to this headline">¶</a></h3>
<p>With the graph constructed we can now turn our attention to the
algorithm we will use to find the shortest solution to the word ladder
problem. The graph algorithm we are going to use is called the “breadth
first search” algorithm. <strong>Breadth first search</strong> (<strong>BFS</strong>) is one of
the easiest algorithms for searching a graph. It also serves as a
prototype for several other important graph algorithms that we will
study later.</p>
<p>Given a graph <span class="math">\(G\)</span> and a starting vertex <span class="math">\(s\)</span>, a breadth
first search proceeds by exploring edges in the graph to find all the
vertices in <span class="math">\(G\)</span> for which there is a path from <span class="math">\(s\)</span>. The
remarkable thing about a breadth first search is that it finds <em>all</em> the
vertices that are a distance <span class="math">\(k\)</span> from <span class="math">\(s\)</span> before it
finds <em>any</em> vertices that are a distance <span class="math">\(k+1\)</span>. One good way to
visualize what the breadth first search algorithm does is to imagine
that it is building a tree, one level of the tree at a time. A breadth
first search adds all children of the starting vertex before it begins
to discover any of the grandchildren.</p>
<p>To keep track of its progress, BFS colors each of the vertices white,
gray, or black. All the vertices are initialized to white when they are
constructed. A white vertex is an undiscovered vertex. When a vertex is
initially discovered it is colored gray, and when BFS has completely
explored a vertex it is colored black. This means that once a vertex is
colored black, it has no white vertices adjacent to it. A gray node, on
the other hand, may have some white vertices adjacent to it, indicating
that there are still additional vertices to explore. {cormen-algorithms}</p>
<p>The breadth first search algorithm shown in Listing&nbsp;{lst:bfs} uses the
adjacency list graph representation we developed earlier in
Listings&nbsp;{lst:vertex} and {lst:graph}. In addition it uses a <tt class="docutils literal"><span class="pre">Queue</span></tt>,
a crucial point as we will see, to decide which vertex to explore next.</p>
<p>In addition the BFS algorithm uses an extended version of the <tt class="docutils literal"><span class="pre">Vertex</span></tt>
class. This new vertex class adds three new instance variables:
distance, predecessor, and color. Each of these instance variables also
has the appropriate getter and setter methods. The code for this
expanded Vertex class is included in the <tt class="docutils literal"><span class="pre">pythonds</span></tt> package, but we
will not show it to you here as there is nothing new to learn by seeing
the additional instance variables.</p>
<p>BFS begins at the starting vertex <tt class="docutils literal"><span class="pre">s</span></tt> and colors <tt class="docutils literal"><span class="pre">start</span></tt> gray to
show that it is currently being explored. Two other values, the distance
and the predecessor, are initialized to 0 and <tt class="docutils literal"><span class="pre">None</span></tt> respectively for
the starting vertex. Finally, <tt class="docutils literal"><span class="pre">start</span></tt> is placed on a <tt class="docutils literal"><span class="pre">Queue</span></tt>. The
next step is to begin to systematically explore vertices at the front of
the queue. We explore each new node at the front of the queue by
iterating over its adjacency list. As each node on the adjacency list is
examined its color is checked. If it is white, the vertex is unexplored,
and four things happen:</p>
<ol class="arabic simple">
<li>The new, unexplored vertex <tt class="docutils literal"><span class="pre">nbr</span></tt>, is colored gray.</li>
<li>The predecessor of <tt class="docutils literal"><span class="pre">nbr</span></tt> is set to the current node <tt class="docutils literal"><span class="pre">currentVert</span></tt></li>
<li>The distance to <tt class="docutils literal"><span class="pre">nbr</span></tt> is set to the distance to <tt class="docutils literal"><span class="pre">currentVert</span> <span class="pre">+</span> <span class="pre">1</span></tt></li>
<li><tt class="docutils literal"><span class="pre">nbr</span></tt> is added to the end of a queue. Adding <tt class="docutils literal"><span class="pre">nbr</span></tt> to the end of
the queue effectively schedules this node for further exploration,
but not until all the other vertices on the adjacency list of
<tt class="docutils literal"><span class="pre">currentVert</span></tt> have been explored.</li>
</ol>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">pythonds.graphs</span> <span class="kn">import</span> <span class="n">Graph</span><span class="p">,</span> <span class="n">Vertex</span>
<span class="kn">from</span> <span class="nn">pythonds.basic</span> <span class="kn">import</span> <span class="n">Queue</span>
<span class="k">def</span> <span class="nf">bfs</span><span class="p">(</span><span class="n">g</span><span class="p">,</span><span class="n">start</span><span class="p">):</span>
  <span class="n">start</span><span class="o">.</span><span class="n">setDistance</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
  <span class="n">start</span><span class="o">.</span><span class="n">setPred</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
  <span class="n">vertQueue</span> <span class="o">=</span> <span class="n">Queue</span><span class="p">()</span>
  <span class="n">vertQueue</span><span class="o">.</span><span class="n">enqueue</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">vertQueue</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>    <span class="c">#// \label{lst:bfs:while}</span>
    <span class="n">currentVert</span> <span class="o">=</span> <span class="n">vertQueue</span><span class="o">.</span><span class="n">dequeue</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">nbr</span> <span class="ow">in</span> <span class="n">currentVert</span><span class="o">.</span><span class="n">getConnections</span><span class="p">():</span>    <span class="c">#// \label{lst:bfs:for}</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">nbr</span><span class="o">.</span><span class="n">getColor</span><span class="p">()</span> <span class="o">==</span> <span class="s">&#39;white&#39;</span><span class="p">):</span>
        <span class="n">nbr</span><span class="o">.</span><span class="n">setColor</span><span class="p">(</span><span class="s">&#39;gray&#39;</span><span class="p">)</span>
        <span class="n">nbr</span><span class="o">.</span><span class="n">setDistance</span><span class="p">(</span><span class="n">currentVert</span><span class="o">.</span><span class="n">getDistance</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">nbr</span><span class="o">.</span><span class="n">setPred</span><span class="p">(</span><span class="n">currentVert</span><span class="p">)</span>
        <span class="n">vertQueue</span><span class="o">.</span><span class="n">enqueue</span><span class="p">(</span><span class="n">nbr</span><span class="p">)</span>
    <span class="n">currentVert</span><span class="o">.</span><span class="n">setColor</span><span class="p">(</span><span class="s">&#39;black&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Let’s look at how the <tt class="docutils literal"><span class="pre">bfs</span></tt> function would construct the breadth first
tree corresponding to the graph in <a class="reference internal" href="#fig-wordladder"><em>Figure 3</em></a>. Starting
from fool we take all nodes that are adjacent to fool and add them to
the tree. The adjacent nodes include pool, foil, foul, and cool. Each of
these nodes are added to the queue of new nodes to expand.
<a class="reference internal" href="#fig-bfs1"><em>Figure 5</em></a> shows the state of the in-progress tree along with the
queue after this step.</p>
<blockquote>
<div><div class="figure align-center">
<img alt="image" src="_images/bfs1.png" />
</div>
</div></blockquote>
<p id="fig-bfs1">In the next step <tt class="docutils literal"><span class="pre">bfs</span></tt> removes the next node (pool) from the front of
the queue and repeats the process for all of its adjacent nodes.
However, when <tt class="docutils literal"><span class="pre">bfs</span></tt> examines the node cool, it finds that the color of
cool has already been changed to gray. This indicates that there is a
shorter path to cool and that cool is already on the queue for further
expansion. The only new node added to the queue while examining pool is
poll. The new state of the tree and queue is shown in <a class="reference internal" href="#fig-bfs2"><em>Figure 6</em></a>.</p>
<blockquote>
<div><div class="figure align-center">
<img alt="image" src="_images/bfs2.png" />
<p class="caption">{The Second Step in the Breadth First Search}</p>
</div>
</div></blockquote>
<p id="fig-bfs2">The next vertex on the queue is foil. The only new node that foil can
add to the tree is fail. As <tt class="docutils literal"><span class="pre">bfs</span></tt> continues to process the queue,
neither of the next two nodes add anything new to the queue or the tree.
<a class="reference internal" href="#fig-bfs3"><em>Figure 7</em></a> shows the tree and the queue after expanding all the
vertices on the second level of the tree.</p>
<blockquote>
<div>[Breadth First Search Tree After Completing One Level] {</div></blockquote>
<blockquote id="fig-bfs3">
<div><div class="figure align-center">
<img alt="image" src="_images/bfs3.png" />
<p class="caption">[Final Breadth First Search Tree]</p>
</div>
</div></blockquote>
<blockquote id="fig-bfsdone">
<div><blockquote>
<div><div class="figure align-center">
<img alt="image" src="_images/bfsDone.png" />
<p class="caption">image</p>
</div>
</div></blockquote>
<p>}{Constructing the Breadth First Search Tree}</p>
</div></blockquote>
<p id="fig-bfscontruct">You should continue to work through the algorithm on your own so that
you are comfortable with how it works. <a class="reference internal" href="#fig-bfsdone"><em>Figure 8</em></a> shows the
final breadth first search tree after all the vertices in
<a class="reference internal" href="#fig-wordladder"><em>Figure 3</em></a> have been expanded. The amazing thing about the
breadth first search solution is that we have not only solved the
FOOL–SAGE problem we started out with, but we have solved many other
problems along the way. We can start at any vertex in the breadth first
search tree and follow the predecessor arrows back to the root to find
the shortest word ladder from any word back to fool. The function in
Listing&nbsp;{lst:traversebfs} shows how to follow the predecessor links to
print out the word ladder.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">traverse</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">y</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">getPred</span><span class="p">()):</span>
        <span class="k">print</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">getId</span><span class="p">())</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">getPred</span><span class="p">()</span>
    <span class="k">print</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">getId</span><span class="p">())</span>

<span class="n">traverse</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">getVertex</span><span class="p">(</span><span class="s">&#39;sage&#39;</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="section" id="breadth-first-search-analysis">
<h3>Breadth First Search Analysis<a class="headerlink" href="#breadth-first-search-analysis" title="Permalink to this headline">¶</a></h3>
<p>{sec:analysis:bfs}</p>
<p>Before we continue with other graph algorithms let us analyze the run
time performance of the breadth first search algorithm. The first thing
to observe is that the while loop on line&nbsp;{lst:bfs:while} is executed,
at most, one time for each vertex in the graph <span class="math">\(|V|\)</span>. You can
see that this is true because a vertex must be white before it can be
examined and added to the queue. This gives us <span class="math">\(O(V)\)</span> for the
while loop. The for loop, which is nested inside the while, on
line&nbsp;{lst:bfs:for} is executed at most once for each edge in the graph,
<span class="math">\(|E|\)</span>. The reason is that every vertex is dequeued at most once
and we examine an edge from node <span class="math">\(u\)</span> to node <span class="math">\(v\)</span> only
when node <span class="math">\(u\)</span> is dequeued. This gives us <span class="math">\(O(E)\)</span> for the
for loop. combining the two loops gives us <span class="math">\(O(V + E)\)</span>.</p>
<p>Of course doing the breadth first search is only part of the task.
Following the links from the starting node to the goal node is the other
part of the task. The worst case for this would be if the graph was a
single long chain. In this case traversing through all of the vertices
would be <span class="math">\(O(V)\)</span>. The normal case is going to be some fraction of
<span class="math">\(|V|\)</span> but we would still write <span class="math">\(O(V)\)</span>.</p>
<p>Finally, at least for this problem, there is the time required to build
the initial graph. We leave the analysis of the <tt class="docutils literal"><span class="pre">buildGraph</span></tt> function
as an exercise for you.</p>
</div>
</div>
<div class="section" id="depth-first-search">
<h2>Depth First Search<a class="headerlink" href="#depth-first-search" title="Permalink to this headline">¶</a></h2>
<div class="section" id="the-knights-tour-problem">
<h3>The Knight’s Tour Problem<a class="headerlink" href="#the-knights-tour-problem" title="Permalink to this headline">¶</a></h3>
<p>Another classic problem that we can use to illustrate a second common
graph algorithm is called the “knight’s tour.” {gordon-kt} The knight’s
tour puzzle is played on a chess board with a single chess piece, the
knight. The object of the puzzle is to find a sequence of moves that
allow the knight to visit every square on the board exactly once. One
such sequence is called a “tour.” The knight’s tour puzzle has
fascinated chess players, mathematicians and computer scientists alike
for many years. The upper bound on the number of possible legal tours
for an eight-by-eight chessboard is known to be
<span class="math">\(1.305 \times 10^{35}\)</span>; however, there are even more possible
dead ends. Clearly this is a problem that requires some real brains,
some real computing power, or both.</p>
<p>Although researchers have studied many different algorithms to solve the
knight’s tour problem, a graph search is one of the easiest to
understand and program. Once again we will solve the problem using two
main steps:</p>
<ul class="simple">
<li>Represent the legal moves of a knight on a chessboard as a graph.</li>
<li>Use a graph algorithm to find a path of length
<span class="math">\(rows \times columns - 1\)</span> where every vertex on the graph is
visited exactly once.</li>
</ul>
</div>
<div class="section" id="building-the-knights-tour-graph">
<h3>Building the Knight’s Tour Graph<a class="headerlink" href="#building-the-knights-tour-graph" title="Permalink to this headline">¶</a></h3>
<p>To represent the knight’s tour problem as a graph we will use the
following two ideas: Each square on the chessboard can be represented as
a node in the graph. Each legal move by the knight can be represented as
an edge in the graph. <a class="reference internal" href="#fig-knightmoves"><em>Figure 10</em></a> illustrates the legal
moves by a knight and the corresponding edges in a graph.</p>
<blockquote>
<div><img alt="image1" src="_images/knightmoves.png" /> {Legal Moves for a Knight on Square 12, and the
Corresponding Graph}</div></blockquote>
<p id="fig-knightmoves">To build the full graph for an n-by-n board we can use the Python
function shown in Listing&nbsp;{lst:ktbuild}. The <tt class="docutils literal"><span class="pre">knightGraph</span></tt> function
makes one pass over the entire board. At each square on the board the
<tt class="docutils literal"><span class="pre">knightGraph</span></tt> function calls a helper, <tt class="docutils literal"><span class="pre">genLegalMoves</span></tt>, to create a
list of legal moves for that position on the board. All legal moves are
then converted into edges in the graph. Another helper function
<tt class="docutils literal"><span class="pre">posToNodeId</span></tt> converts a location on the board in terms of a row and a
column into a linear vertex number similar to the vertex numbers shown
in <a class="reference internal" href="#fig-knightmoves"><em>Figure 10</em></a>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">pythonds.graphs</span> <span class="kn">import</span> <span class="n">Graph</span>
<span class="k">def</span> <span class="nf">knightGraph</span><span class="p">(</span><span class="n">bdSize</span><span class="p">):</span>
    <span class="n">ktGraph</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">bdSize</span><span class="p">):</span>
       <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">bdSize</span><span class="p">):</span>
           <span class="n">nodeId</span> <span class="o">=</span> <span class="n">posToNodeId</span><span class="p">(</span><span class="n">row</span><span class="p">,</span><span class="n">col</span><span class="p">,</span><span class="n">bdSize</span><span class="p">)</span>
           <span class="n">newPositions</span> <span class="o">=</span> <span class="n">genLegalMoves</span><span class="p">(</span><span class="n">row</span><span class="p">,</span><span class="n">col</span><span class="p">,</span><span class="n">bdSize</span><span class="p">)</span>
           <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">newPositions</span><span class="p">:</span>
               <span class="n">nid</span> <span class="o">=</span> <span class="n">posToNodeId</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
               <span class="n">ktGraph</span><span class="o">.</span><span class="n">addEdge</span><span class="p">(</span><span class="n">nodeId</span><span class="p">,</span><span class="n">nid</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ktGraph</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">genLegalMoves</span></tt> function takes the position of the knight on the
board and generates each of the eight possible moves. The <tt class="docutils literal"><span class="pre">legalCoord</span></tt>
helper function makes sure that a particular move that is generated is
still on the board.</p>
<div class="highlight-python"><pre>def genLegalMoves(x,y,bdSize):
    newMoves = []
    moveOffsets = [(-1,-2),(-1,2),(-2,-1),(-2,1),
                   ( 1,-2),( 1,2),( 2,-1),( 2,1)]:
    for i in moveOffsets:
        newX = x + i[0]
        newY = y + i[1]
        if legalCoord(newX,bdSize) and \
                        legalCoord(newY,bdSize):
            newMoves.append((newX,newY))
    return newMoves

def legalCoord(x,bdSize):
    if x &gt;= 0 and x &lt; bdSize:
        return True
    else:
        return False</pre>
</div>
<p><a class="reference internal" href="#fig-bigknight"><em>Figure 11</em></a> shows the complete graph of possible moves on an
eight-by-eight board. There are exactly 336 edges in the graph. Notice
that the vertices corresponding to the edges of the board have fewer
connections (legal moves) than the vertices in the middle of the board.
Once again we can see how sparse the graph is. If the graph was fully
connected there would be 4,096 edges. Since there are only 336 edges,
the adjacency matrix would be only 8.2 percent full.</p>
<blockquote>
<div><blockquote>
<div><div class="figure align-center">
<img alt="image" src="_images/bigknight.png" />
<p class="caption">image</p>
</div>
</div></blockquote>
<p>{All Legal Moves for a Knight on an <span class="math">\(8 \times 8\)</span> Chessboard}</p>
</div></blockquote>
</div>
<div class="section" id="implementing-knights-tour">
<span id="fig-bigknight"></span><h3>Implementing Knight’s Tour<a class="headerlink" href="#implementing-knights-tour" title="Permalink to this headline">¶</a></h3>
<p>The search algorithm we will use to solve the knight’s tour problem is
called <strong>depth first search**(**DFS</strong>). {cormen-algorithms} Whereas the
breadth first search algorithm discussed in the previous section builds
a search tree one level at a time, a depth first search creates a search
tree by exploring one branch of the tree as deeply as possible. In this
section we will look at two algorithms that implement a depth first
search. The first algorithm we will look at directly solves the knight’s
tour problem by explicitly forbidding a node to be visited more than
once. The second implementation is more general, but allows nodes to be
visited more than once as the tree is constructed. The second version is
used in subsequent sections to develop additional graph algorithms.</p>
<p>The depth first exploration of the graph is exactly what we need in
order to find a path that has exactly 63 edges. We will see that when
the depth first search algorithm finds a dead end (a place in the graph
where there are no more moves possible) it backs up the tree to the next
deepest vertex that allows it to make a legal move.</p>
<p>The <tt class="docutils literal"><span class="pre">knightTour</span></tt> function takes four parameters: <tt class="docutils literal"><span class="pre">n</span></tt>, the current
depth in the search tree; <tt class="docutils literal"><span class="pre">path</span></tt>, a list of vertices visited up to
this point; <tt class="docutils literal"><span class="pre">u</span></tt>, the vertex in the graph we wish to explore; and
<tt class="docutils literal"><span class="pre">limit</span></tt> the number of nodes in the path. The <tt class="docutils literal"><span class="pre">knightTour</span></tt> function
is recursive. When the <tt class="docutils literal"><span class="pre">knightTour</span></tt> function is called, it first
checks the base case condition. If we have a path that contains 64
vertices, we return from <tt class="docutils literal"><span class="pre">knightTour</span></tt> with a status of <tt class="docutils literal"><span class="pre">True</span></tt>,
indicating that we have found a successful tour. If the path is not long
enough we continue to explore one level deeper by choosing a new vertex
to explore and calling <tt class="docutils literal"><span class="pre">knightTour</span></tt> recursively for that vertex.</p>
<p>DFS also uses colors to keep track of which vertices in the graph have
been visited. Unvisited vertices are colored white, and visited vertices
are colored gray. If all neighbors of a particular vertex have been
explored and we have not yet reached our goal length of 64 vertices, we
have reached a dead end. When we reach a dead end we must backtrack.
Backtracking happens when we return from <tt class="docutils literal"><span class="pre">knightTour</span></tt> with a status of
<tt class="docutils literal"><span class="pre">False</span></tt>. In the breadth first search we used a queue to keep track of
which vertex to visit next. Since depth first search is recursive, we
are implicitly using a stack to help us with our backtracking. When we
return from a call to <tt class="docutils literal"><span class="pre">knightTour</span></tt> with a status of <tt class="docutils literal"><span class="pre">False</span></tt>, in line
{lst:kt:bt}, we remain inside the <tt class="docutils literal"><span class="pre">while</span></tt> loop and look at the next
vertex in <a href="#id1"><span class="problematic" id="id2">``</span></a>nbrList}.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">pythonds.graphs</span> <span class="kn">import</span> <span class="n">Graph</span><span class="p">,</span> <span class="n">Vertex</span>
<span class="k">def</span> <span class="nf">knightTour</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">path</span><span class="p">,</span><span class="n">u</span><span class="p">,</span><span class="n">limit</span><span class="p">):</span>
        <span class="n">u</span><span class="o">.</span><span class="n">setColor</span><span class="p">(</span><span class="s">&#39;gray&#39;</span><span class="p">)</span>
        <span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">limit</span><span class="p">:</span>
            <span class="n">nbrList</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">getConnections</span><span class="p">())</span>  <span class="c">#// \label{lst:kt:oba}</span>
            <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">done</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">nbrList</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">done</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">nbrList</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">getColor</span><span class="p">()</span> <span class="o">==</span> <span class="s">&#39;white&#39;</span><span class="p">:</span>
                    <span class="n">done</span> <span class="o">=</span> <span class="n">knightTour</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span>      <span class="c">#// \label{lst:kt:bt}</span>
                                  <span class="n">path</span><span class="p">,</span>
                                  <span class="n">nbrList</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                                  <span class="n">limit</span><span class="p">)</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">done</span><span class="p">:</span>  <span class="c"># prepare to backtrack</span>
                <span class="n">path</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="n">u</span><span class="o">.</span><span class="n">setColor</span><span class="p">(</span><span class="s">&#39;white&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">done</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="n">done</span>
</pre></div>
</div>
<p>Let&#8217;s look at a simple example of texttt``knightTour} in action. You
can refer to <a class="reference internal" href="#fig-ktexamp"><em>Figure 20</em></a> to follow the steps of the search. For
this example we will assume that the call to the <tt class="docutils literal"><span class="pre">getConnections</span></tt>
method on line {lst:kt:oba} of Listing&nbsp;{lst:knight} orders the nodes in
alphabetical order. We begin by calling <tt class="docutils literal"><span class="pre">knightTour(0,path,A,6)</span></tt></p>
<p><tt class="docutils literal"><span class="pre">knightTour</span></tt> starts with node A. The nodes adjacent to A are B and D.
Since B is before D alphabetically, DFS selects B to expand next as
shown in <a class="reference internal" href="#fig-ktb"><em>Figure 13</em></a>. Exploring B happens when <tt class="docutils literal"><span class="pre">knightTour</span></tt> is
called recursively. B is adjacent to C and D, so <tt class="docutils literal"><span class="pre">knightTour</span></tt> elects
to explore C next. However, as you can see in <a class="reference internal" href="#fig-ktc"><em>Figure 14</em></a> node C is
a dead end with no adjacent white nodes. At this point we change the
color of node C back to white. The call to <tt class="docutils literal"><span class="pre">knightTour</span></tt> returns a
value of <tt class="docutils literal"><span class="pre">False</span></tt>. The return from the recursive call effectively
backtracks the search to vertex B (see <a class="reference internal" href="#fig-ktd"><em>Figure 15</em></a>). The next
vertex on the list to explore is vertex D, so <tt class="docutils literal"><span class="pre">knightTour</span></tt> makes a
recursive call moving to node D. From vertex D on,
<tt class="docutils literal"><span class="pre">knightTour}</span> <span class="pre">can</span> <span class="pre">continue</span> <span class="pre">to</span> <span class="pre">make</span> <span class="pre">recursive</span> <span class="pre">calls</span> <span class="pre">until</span> <span class="pre">we</span>
<span class="pre">get</span> <span class="pre">to</span> <span class="pre">node</span> <span class="pre">C</span> <span class="pre">again.</span>&nbsp; <span class="pre">However,</span> <span class="pre">this</span> <span class="pre">time</span> <span class="pre">when</span> <span class="pre">we</span> <span class="pre">get</span> <span class="pre">to</span> <span class="pre">node</span> <span class="pre">C</span> <span class="pre">the</span>
<span class="pre">test</span> <span class="pre">\texttt``n</span> <span class="pre">&lt;</span> <span class="pre">limit}</span> <span class="pre">fails</span> <span class="pre">so</span> <span class="pre">we</span> <span class="pre">know</span> <span class="pre">that</span> <span class="pre">we</span> <span class="pre">have</span> <span class="pre">exhausted</span> <span class="pre">all</span> <span class="pre">the</span>
<span class="pre">nodes</span> <span class="pre">in</span> <span class="pre">the</span> <span class="pre">graph.</span> <span class="pre">At</span> <span class="pre">this</span> <span class="pre">point</span> <span class="pre">we</span> <span class="pre">can</span> <span class="pre">return</span> <span class="pre">``True</span></tt> to indicate
that we have made a successful tour of the graph. When we return the
list, <tt class="docutils literal"><span class="pre">path</span></tt> has the values <tt class="docutils literal"><span class="pre">[A,B,D,E,F,C]</span></tt>, which is the the order
we need to traverse the graph to visit each node exactly once.</p>
<blockquote>
<div>[Start with node A] {</div></blockquote>
<blockquote id="fig-kta">
<div><blockquote>
<div><div class="figure align-center">
<img alt="image" src="_images/ktdfsa.png" />
<p class="caption">image</p>
</div>
</div></blockquote>
<p>}[Explore B] {</p>
</div></blockquote>
<blockquote id="fig-ktb">
<div><blockquote>
<div><div class="figure align-center">
<img alt="image" src="_images/ktdfsb.png" />
<p class="caption">image</p>
</div>
</div></blockquote>
<p>}[node C is a dead end] {</p>
</div></blockquote>
<blockquote id="fig-ktc">
<div><blockquote>
<div><div class="figure align-center">
<img alt="image" src="_images/ktdfsc.png" />
<p class="caption">image</p>
</div>
</div></blockquote>
<p>} [backtrack to B] {</p>
</div></blockquote>
<blockquote id="fig-ktd">
<div><blockquote>
<div><div class="figure align-center">
<img alt="image" src="_images/ktdfsd.png" />
<p class="caption">image</p>
</div>
</div></blockquote>
<p>}[] {</p>
</div></blockquote>
<blockquote id="fig-kte">
<div><blockquote>
<div><div class="figure align-center">
<img alt="image" src="_images/ktdfse.png" />
<p class="caption">image</p>
</div>
</div></blockquote>
<p>}[] {</p>
</div></blockquote>
<blockquote id="fig-ktf">
<div><blockquote>
<div><div class="figure align-center">
<img alt="image" src="_images/ktdfsf.png" />
<p class="caption">image</p>
</div>
</div></blockquote>
<p>} [] {</p>
</div></blockquote>
<blockquote id="fig-ktg">
<div><blockquote>
<div><div class="figure align-center">
<img alt="image" src="_images/ktdfsg.png" />
<p class="caption">image</p>
</div>
</div></blockquote>
<p>}[finish] {</p>
</div></blockquote>
<blockquote id="fig-kth">
<div><blockquote>
<div><div class="figure align-center">
<img alt="image" src="_images/ktdfsh.png" />
<p class="caption">image</p>
</div>
</div></blockquote>
<p>} {Finding a Path through a Graph with <tt class="docutils literal"><span class="pre">knightTour</span></tt>}</p>
</div></blockquote>
<p id="fig-ktexamp"><a class="reference internal" href="#fig-tour"><em>Figure 21</em></a> shows you what a complete tour around an
eight-by-eight board looks like. There are many possible tours; some are
symmetric. With some modification you can make circular tours that start
and end at the same square.</p>
<blockquote>
<div><blockquote>
<div><div class="figure align-center">
<img alt="image" src="_images/completeTour.png" />
<p class="caption">image</p>
</div>
</div></blockquote>
<p>{A Complete Tour of the Board}</p>
</div></blockquote>
</div>
<div class="section" id="knights-tour-analysis">
<span id="fig-tour"></span><h3>Knight’s Tour Analysis<a class="headerlink" href="#knights-tour-analysis" title="Permalink to this headline">¶</a></h3>
<p>There is one last interesting topic regarding the knight’s tour problem,
then we will move on to the general version of the depth first search.
The topic is performance. In particular, <tt class="docutils literal"><span class="pre">knightTour</span></tt> is very
sensitive to the method you use to select the next vertex to visit. For
example, on a five-by-five board you can produce a path in about 1.5
seconds on a reasonably fast computer. But what happens if you try an
eight-by-eight board? In this case, depending on the speed of your
computer, you may have to wait up to a half hour to get the results! The
reason for this is that the knight’s tour problem as we have implemented
it so far is an exponential algorithm of size <span class="math">\(O(k^N)\)</span>, where N
is the number of squares on the chess board, and k is a small constant.
<a class="reference internal" href="#fig-8array"><em>Figure 22</em></a> can help us visualize why this is so. The root of
the tree represents the starting point of the search. From there the
algorithm generates and checks each of the possible moves the knight can
make. As we have noted before the number of moves possible depends on
the position of the knight on the board. In the corners there are only
two legal moves, on the squares adjacent to the corners there are three
and in the middle of the board there are eight. <a class="reference internal" href="#fig-nummoves"><em>Figure 23</em></a>
shows the number of moves possible for each position on a board. At the
next level of the tree there are once again between 2 and 8 possible
next moves from the position we are currently exploring. The number of
possible positions to examine corresponds to the number of nodes in the
search tree.</p>
<blockquote>
<div><img alt="image2" src="_images/8arrayTree.png" /> {A Search Tree for the Knight’s Tour}</div></blockquote>
<blockquote id="fig-8array">
<div><img alt="image3" src="_images/moveCount.png" /> {Number of Possible Moves for Each Square}</div></blockquote>
<p id="fig-nummoves">We have already seen that the number of nodes in a binary tree of height
N is <span class="math">\(2^{N+1}-1\)</span>. For a tree with nodes that may have up to
eight children instead of two the number of nodes is much larger.
Because the branching factor of each node is variable, we could estimate
the number of nodes using an average branching factor. The important
thing to note is that this algorithm is exponential:
<span class="math">\(k^{N+1}-1\)</span>, where <span class="math">\(k\)</span> is the average branching factor
for the board. Let’s look at how rapidly this grows! For a board that is
5x5 the tree will be 25 levels deep, or N = 24 counting the first level
as level 0. The average branching factor is <span class="math">\(k = 3.8\)</span> So the
number of nodes in the search tree is <span class="math">\(3.8^{25}-1\)</span> or
<span class="math">\(3.12 \times 10^{14}\)</span>. For a 6x6 board, <span class="math">\(k = 4.4\)</span>, there
are <span class="math">\(1.5
\times 10^{23}\)</span> nodes, and for a regular 8x8 chess board,
<span class="math">\(k = 5.25\)</span>, there are <span class="math">\(1.3 \times 10^{46}\)</span>. Of course,
since there are multiple solutions to the problem we won’t have to
explore every single node, but the fractional part of the nodes we do
have to explore is just a constant multiplier which does not change the
exponential nature of the problem. We will leave it as an exercise for
you to see if you can express <span class="math">\(k\)</span> as a function of the board
size.</p>
<p>Luckily there is a way to speed up the eight-by-eight case so that it
runs in under one second. In Listing&nbsp;{lst:oba} we show the code that
speeds up the <tt class="docutils literal"><span class="pre">knightTour</span></tt>. This function, called <tt class="docutils literal"><span class="pre">orderbyAvail</span></tt>
will be used in place of the call to <tt class="docutils literal"><span class="pre">u.getConnections</span></tt> on
line&nbsp;{lst:kt:oba} of Listing&nbsp;{lst:knight}. The critical line in the
<tt class="docutils literal"><span class="pre">orderByAvail</span></tt> function is {lst:oba:sort}. This line ensures that we
select the vertex to go next that has the fewest available moves. You
might think this is really counter productive; why not select the node
that has the most available moves? You can try that approach easily by
running the program yourself and inserting the line
<tt class="docutils literal"><span class="pre">resList.reverse()</span></tt> right after the sort.</p>
<p>The problem with using the vertex with the most available moves as your
next vertex on the path is that it tends to have the knight visit the
middle squares early on in the tour. When this happens it is easy for
the knight to get stranded on one side of the board where it cannot
reach unvisited squares on the other side of the board. On the other
hand, visiting the squares with the fewest available moves first pushes
the knight to visit the squares around the edges of the board first.
This ensures that the knight will visit the hard-to-reach corners early
and can use the middle squares to hop across the board only when
necessary. Utilizing this kind of knowledge to speed up an algorithm is
called a heuristic. Humans use heuristics every day to help make
decisions, heuristic searches are often used in the field of artificial
intelligence. This particular heuristic is called Warnsdorff’s
algorithm, named after H. C. Warnsdorff who published his idea in 1823.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">orderByAvail</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="n">resList</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">geConnections</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">getColor</span><span class="p">()</span> <span class="o">==</span> <span class="s">&#39;white&#39;</span><span class="p">:</span>
            <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">v</span><span class="o">.</span><span class="n">getConnections</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">w</span><span class="o">.</span><span class="n">getColor</span><span class="p">()</span> <span class="o">==</span> <span class="s">&#39;white&#39;</span><span class="p">:</span>
                    <span class="n">c</span> <span class="o">=</span> <span class="n">c</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">resList</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">c</span><span class="p">,</span><span class="n">v</span><span class="p">))</span>
    <span class="n">resList</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  <span class="c">#// \label{lst:oba:sort}</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">resList</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="section" id="general-depth-first-search">
<h3>General Depth First Search<a class="headerlink" href="#general-depth-first-search" title="Permalink to this headline">¶</a></h3>
<p>The knight’s tour is a special case of a depth first search where the
goal is to create the deepest depth first tree, without any branches.
The more general depth first search is actually easier. Its goal is to
search as deeply as possible, connecting as many nodes in the graph as
possible and branching where necessary.</p>
<p>It is even possible that a depth first search will create more than one
tree. When the depth first search algorithm creates a group of trees we
call this a <strong>depth first forest</strong>. As with the breadth first search our
depth first search makes use of predecessor links to construct the tree.
In addition, the depth first search will make use of two additional
instance variables in the <tt class="docutils literal"><span class="pre">Vertex</span></tt> class. The new instance variables
are the discovery and finish times. The discovery time tracks the number
of steps in the algorithm before a vertex is first encountered. The
finish time is the number of steps in the algorithm before a vertex is
colored black. As we will see after looking at the algorithm, the
discovery and finish times of the nodes provide some interesting
properties we can use in later algorithms.</p>
<p>The code for our depth first search is shown in Listing&nbsp;{lst:dfs}. Since
the two functions <tt class="docutils literal"><span class="pre">dfs</span></tt> and its helper <tt class="docutils literal"><span class="pre">dfsvisit</span></tt> use a variable to
keep track of the time across calls to <tt class="docutils literal"><span class="pre">dfsvisit</span></tt> we chose to
implement the code as methods of a class that inherits from the
<tt class="docutils literal"><span class="pre">Graph</span></tt> class. This implementation extends the graph class by adding a
<tt class="docutils literal"><span class="pre">time</span></tt> instance variable and the two methods <tt class="docutils literal"><span class="pre">dfs</span></tt> and <tt class="docutils literal"><span class="pre">dfsvisit</span></tt>.
Looking at line&nbsp;{lst:dfs:iter} you will notice that the <tt class="docutils literal"><span class="pre">dfs</span></tt> method
iterates over all of the vertices in the graph calling <tt class="docutils literal"><span class="pre">dfsvisit</span></tt> on
the nodes that are white. The reason we iterate over all the nodes,
rather than simply searching from a chosen starting node, is to make
sure that all nodes in the graph are considered and that no vertices are
left out of the depth first forest. It may look unusual to see the
statement {for aVertex in self}, but remember that in this case <tt class="docutils literal"><span class="pre">self</span></tt>
is an instance of the <tt class="docutils literal"><span class="pre">DFSGraph</span></tt> class, and iterating over all the
vertices in an instance of a graph is a natural thing to do.</p>
<p>Although our implementation of <tt class="docutils literal"><span class="pre">bfs</span></tt> was only interested in
considering nodes for which there was a path leading back to the start,
it is possible to create a breadth first forest that represents the
shortest path between all pairs of nodes in the graph. We leave this as
an exercise. In our next two algorithms we will see why keeping track of
the depth first forest is important.</p>
<p>The <tt class="docutils literal"><span class="pre">dfsvisit</span></tt> method starts with a single vertex called
<tt class="docutils literal"><span class="pre">startVertex</span></tt> and explores all of the neighboring white vertices as
deeply as possible. If you look carefully at the code for <tt class="docutils literal"><span class="pre">dfsvisit</span></tt>
and compare it to breadth first search, what you should notice is that
the <tt class="docutils literal"><span class="pre">dfsvisit</span></tt> algorithm is almost identical to <tt class="docutils literal"><span class="pre">bfs</span></tt> except that on
the last line of the inner <tt class="docutils literal"><span class="pre">for</span></tt> loop, <tt class="docutils literal"><span class="pre">dfsvisit</span></tt> calls itself
recursively to continue the search at a deeper level, whereas <tt class="docutils literal"><span class="pre">bfs</span></tt>
adds the node to a queue for later exploration. It is interesting to
note that where <tt class="docutils literal"><span class="pre">bfs</span></tt> uses a queue, <tt class="docutils literal"><span class="pre">dfsvisit</span></tt> uses a stack. You
don’t see a stack in the code, but it is implicit in the recursive call
to <tt class="docutils literal"><span class="pre">dfsvisit</span></tt>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">pythonds.graphs</span> <span class="kn">import</span> <span class="n">Graph</span>
<span class="k">class</span> <span class="nc">DFSGraph</span><span class="p">(</span><span class="n">Graph</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">aVertex</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>   <span class="c">#// \label{lst:dfs:init}</span>
            <span class="n">aVertex</span><span class="o">.</span><span class="n">setColor</span><span class="p">(</span><span class="s">&#39;white&#39;</span><span class="p">)</span>
            <span class="n">aVertex</span><span class="o">.</span><span class="n">setPred</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">aVertex</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>   <span class="c">#// \label{lst:dfs:iter}</span>
            <span class="k">if</span> <span class="n">aVertex</span><span class="o">.</span><span class="n">getColor</span><span class="p">()</span> <span class="o">==</span> <span class="s">&#39;white&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dfsvisit</span><span class="p">(</span><span class="n">aVertex</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">dfsvisit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">startVertex</span><span class="p">):</span>
        <span class="n">startVertex</span><span class="o">.</span><span class="n">setColor</span><span class="p">(</span><span class="s">&#39;gray&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">startVertex</span><span class="o">.</span><span class="n">setDiscovery</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">nextVertex</span> <span class="ow">in</span> <span class="n">startVertex</span><span class="o">.</span><span class="n">getConnections</span><span class="p">():</span> <span class="c">#// \label{lst:dfsvisit:loop}</span>
            <span class="k">if</span> <span class="n">nextVertex</span><span class="o">.</span><span class="n">getColor</span><span class="p">()</span> <span class="o">==</span> <span class="s">&#39;white&#39;</span><span class="p">:</span>
                <span class="n">nextVertex</span><span class="o">.</span><span class="n">setPred</span><span class="p">(</span><span class="n">startVertex</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dfsvisit</span><span class="p">(</span><span class="n">nextVertex</span><span class="p">)</span>
        <span class="n">startVertex</span><span class="o">.</span><span class="n">setColor</span><span class="p">(</span><span class="s">&#39;black&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">startVertex</span><span class="o">.</span><span class="n">setFinish</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">)</span>
</pre></div>
</div>
<p><a class="reference internal" href="#fig-dfsexamp"><em>Figure 36</em></a> illustrates the depth first search algorithm in
action for a small graph. In <a class="reference internal" href="#fig-dfsexamp"><em>Figure 36</em></a> the dotted lines
indicate edges that are checked, but the node at the other end of the
edge has already been added to the depth first tree. In the code this
test is done by checking that the color of the other node is non-white.</p>
<p>The search begins at vertex A of the graph. Since all of the vertices
are white at the beginning of the search the algorithm visits vertex A.
The first step in visiting a vertex is to set the color to gray, which
indicates that the vertex is being explored and the discovery time is
set to 1. Since vertex A has two adjacent vertices (B, D) each of those
need to be visited as well. We’ll make the arbitrary decision that we
will visit the adjacent vertices in alphabetical order.</p>
<p>Vertex B is visited next, so its color is set to gray and its discovery
time is set to 2. Vertex B is also adjacent to two other nodes (C, D) so
we will follow the alphabetical order and visit node C next.</p>
<p>Visiting vertex C brings us to the end of one branch of the tree. After
coloring the node gray and setting its discovery time to 3, the
algorithm also determines that there are no adjacent vertices to C. This
means that we are done exploring node C and so we can color the vertex
black, and set the finish time to 4. You can see the state of our search
at this point in <a class="reference internal" href="#fig-gdfsd"><em>Figure 27</em></a>.</p>
<p>Since vertex C was the end of one branch we now return to vertex B and
continue exploring the nodes adjacent to B. The only additional vertex
to explore from B is D, so we can now visit D and continue our search
from vertex D. Vertex D quickly leads us to vertex E. Vertex E has two
adjacent vertices, B and F. Normally we would explore these adjacent
vertices alphabetically, but since B is already colored gray the
algorithm recognizes that it should not visit B since doing so would put
the algorithm in a loop! So exploration continues with the next vertex
in the list, namely F.</p>
<p>Vertex F has only one adjacent vertex, C, but since C is colored black
there is nothing else to explore, and the algorithm has reached the end
of another branch. From here on, you will see in Figures&nbsp;.. _fig_gdfsh –
.. _fig_gdfsl that the algorithm works its way back to the first node,
setting finish times and coloring vertices black.</p>
<blockquote>
<div>[] {</div></blockquote>
<blockquote id="fig-gdfsa">
<div><blockquote>
<div><div class="figure align-center">
<img alt="image" src="_images/gendfsa.png" />
<p class="caption">image</p>
</div>
</div></blockquote>
<p>}[] {</p>
</div></blockquote>
<blockquote id="fig-gdfsb">
<div><blockquote>
<div><div class="figure align-center">
<img alt="image" src="_images/gendfsb.png" />
<p class="caption">image</p>
</div>
</div></blockquote>
<p>}[] {</p>
</div></blockquote>
<blockquote id="fig-gdfsc">
<div><blockquote>
<div><div class="figure align-center">
<img alt="image" src="_images/gendfsc.png" />
<p class="caption">image</p>
</div>
</div></blockquote>
<p>} [] {</p>
</div></blockquote>
<blockquote id="fig-gdfsd">
<div><blockquote>
<div><div class="figure align-center">
<img alt="image" src="_images/gendfsd.png" />
<p class="caption">image</p>
</div>
</div></blockquote>
<p>}[] {</p>
</div></blockquote>
<blockquote id="fig-gdfse">
<div><blockquote>
<div><div class="figure align-center">
<img alt="image" src="_images/gendfse.png" />
<p class="caption">image</p>
</div>
</div></blockquote>
<p>}[] {</p>
</div></blockquote>
<blockquote id="fig-gdfsf">
<div><blockquote>
<div><div class="figure align-center">
<img alt="image" src="_images/gendfsf.png" />
<p class="caption">image</p>
</div>
</div></blockquote>
<p>} [] {</p>
</div></blockquote>
<blockquote id="fig-gdfsg">
<div><blockquote>
<div><div class="figure align-center">
<img alt="image" src="_images/gendfsg.png" />
<p class="caption">image</p>
</div>
</div></blockquote>
<p>}[] {</p>
</div></blockquote>
<blockquote id="fig-gdfsh">
<div><blockquote>
<div><div class="figure align-center">
<img alt="image" src="_images/gendfsh.png" />
<p class="caption">image</p>
</div>
</div></blockquote>
<p>}[] {</p>
</div></blockquote>
<blockquote id="fig-gdfsi">
<div><blockquote>
<div><div class="figure align-center">
<img alt="image" src="_images/gendfsi.png" />
<p class="caption">image</p>
</div>
</div></blockquote>
<p>} [] {</p>
</div></blockquote>
<blockquote id="fig-gdfsj">
<div><blockquote>
<div><div class="figure align-center">
<img alt="image" src="_images/gendfsj.png" />
<p class="caption">image</p>
</div>
</div></blockquote>
<p>}[] {</p>
</div></blockquote>
<blockquote id="fig-gdfsk">
<div><blockquote>
<div><div class="figure align-center">
<img alt="image" src="_images/gendfsk.png" />
<p class="caption">image</p>
</div>
</div></blockquote>
<p>}[] {</p>
</div></blockquote>
<blockquote id="fig-gdfsl">
<div><blockquote>
<div><div class="figure align-center">
<img alt="image" src="_images/gendfsl.png" />
<p class="caption">image</p>
</div>
</div></blockquote>
<p>} {Constructing the Depth First Search Tree}</p>
</div></blockquote>
<p id="fig-dfsexamp">The starting and finishing times for each node display a property called
the <strong>parenthesis property</strong>. This property means that all the children
of a particular node in the depth first tree have a later discovery time
and an earlier finish time than their parent. <a class="reference internal" href="#fig-dfstree"><em>Figure 37</em></a> shows
the tree constructed by the depth first search algorithm.</p>
<blockquote>
<div><blockquote>
<div><div class="figure align-center">
<img alt="image" src="_images/dfstree.png" />
<p class="caption">image</p>
</div>
</div></blockquote>
<p>{The Resulting Depth First Search Tree}</p>
</div></blockquote>
</div>
<div class="section" id="depth-first-search-analysis">
<span id="fig-dfstree"></span><h3>Depth First Search Analysis<a class="headerlink" href="#depth-first-search-analysis" title="Permalink to this headline">¶</a></h3>
<p>{sec:depth-first-search}</p>
<p>The general running time for depth first search is as follows. The loops
on lines&nbsp;{lst:dfs:init}&nbsp;and&nbsp;{lst:dfs:iter} both run in <span class="math">\(O(V)\)</span>,
not counting what happens in <tt class="docutils literal"><span class="pre">dfsvisit</span></tt>, since they are executed once
for each vertex in the graph. In <tt class="docutils literal"><span class="pre">dfsvisit</span></tt> the loop on
line&nbsp;{lst:dfsvisit:loop} is executed once for each edge in the adjacency
list of the current vertex. Since <tt class="docutils literal"><span class="pre">dfsvisit</span></tt> is only called
recursively if the vertex is white, the loop will execute a maximum of
once for every edge in the graph or <span class="math">\(O(E)\)</span>. So, the total time
for depth first search is <span class="math">\(O(V + E)\)</span>.</p>
</div>
</div>
<div class="section" id="topological-sorting">
<h2>Topological Sorting<a class="headerlink" href="#topological-sorting" title="Permalink to this headline">¶</a></h2>
<p>To demonstrate that computer scientists can turn just about anything
into a graph problem, let’s consider the difficult problem of stirring
up a batch of pancakes. The recipe is really quite simple: 1 egg, 1 cup
of pancake mix, 1 tablespoon oil, and <span class="math">\(3 \over 4\)</span> cup of milk.
To make pancakes you must heat the griddle, mix all the ingredients
together and spoon the mix onto a hot griddle. When the pancakes start
to bubble you turn them over and let them cook until they are golden
brown on the bottom. Before you eat your pancakes you are going to want
to heat up some syrup. <a class="reference internal" href="#fig-pancakes"><em>Figure 38</em></a> illustrates this process as
a graph.</p>
<blockquote>
<div><blockquote>
<div><div class="figure align-center">
<img alt="image" src="_images/pancakes.png" />
<p class="caption">image</p>
</div>
</div></blockquote>
<p>{The Steps for Making Pancakes}</p>
</div></blockquote>
<p id="fig-pancakes">The difficult thing about making pancakes is knowing what to do first.
As you can see from <a class="reference internal" href="#fig-pancakes"><em>Figure 38</em></a> you might start by heating the
griddle or by adding any of the ingredients to the pancake mix. To help
us decide the precise order in which we should do each of the steps
required to make our pancakes we turn to a graph algorithm called the
<strong>topological sort</strong>.</p>
<p>A topological sort takes a directed acyclic graph and produces a linear
ordering of all its vertices such that if the graph <span class="math">\(G\)</span> contains
an edge <span class="math">\((v,w)\)</span> then the vertex <span class="math">\(v\)</span> comes before the
vertex <span class="math">\(w\)</span> in the ordering. Directed acyclic graphs are used in
many applications to indicate the precedence of events. Making pancakes
is just one example; other examples include software project schedules,
precedence charts for optimizing database queries, and multiplying
matrices.</p>
<p>The topological sort is a simple but useful adaptation of a depth first
search. The algorithm for the topological sort is as follows:</p>
<ol class="arabic simple">
<li>Call <tt class="docutils literal"><span class="pre">dfs(g)</span></tt> for some graph <tt class="docutils literal"><span class="pre">g</span></tt>. The main reason we want to call
depth first search is to compute the finish times for each of the
vertices.</li>
<li>Store the vertices in a list in decreasing order of finish time.</li>
<li>Return the ordered list as the result of the topological sort.</li>
</ol>
<p><a class="reference internal" href="#fig-pancakesdfs"><em>Figure 39</em></a> shows the depth first forest constructed by
<tt class="docutils literal"><span class="pre">dfs</span></tt> on the pancake-making graph shown in <a class="reference internal" href="#fig-pancakes"><em>Figure 38</em></a>.</p>
<blockquote>
<div><blockquote>
<div><div class="figure align-center">
<img alt="image" src="_images/pancakesDFS.png" />
<p class="caption">image</p>
</div>
</div></blockquote>
<p>{Result of Depth First Search on the Pancake Graph}</p>
</div></blockquote>
<p id="fig-pancakesdfs">Finally, <a class="reference internal" href="#fig-pancakests"><em>Figure 40</em></a> shows the results of applying the
topological sort algorithm to our graph. Now all the ambiguity has been
removed and we know exactly the order in which to perform the pancake
making steps.</p>
<blockquote>
<div><blockquote>
<div><div class="figure align-center">
<img alt="image" src="_images/pancakesTS.png" />
<p class="caption">image</p>
</div>
</div></blockquote>
<p>{Result of Topological Sort on Directed Acyclic Graph}</p>
</div></blockquote>
</div>
<div class="section" id="strongly-connected-components">
<span id="fig-pancakests"></span><h2>Strongly Connected Components<a class="headerlink" href="#strongly-connected-components" title="Permalink to this headline">¶</a></h2>
<p>For the remainder of this chapter we will turn our attention to some
extremely large graphs. The graphs we will use to study some additional
algorithms are the graphs produced by the connections between hosts on
the Internet and the links between web pages. We will begin with web
pages.</p>
<p>Search engines like Google and Bing exploit the fact that the pages on
the web form a very large directed graph. To transform the World Wide
Web into a graph, we will treat a page as a vertex, and the hyperlinks
on the page as edges connecting one vertex to another.
<a class="reference internal" href="#fig-cshome"><em>Figure 41</em></a> shows a very small part of the graph produced by
following the links from one page to the next, beginning at Luther
College’s Computer Science home page. Of course, this graph could be
huge, so we have limited it to web sites that are no more than 10 links
away from the CS home page.</p>
<blockquote>
<div><div class="figure align-center">
<img alt="image" src="_images/cshome.png" />
<p class="caption">image</p>
</div>
<p>{The Graph Produced by Links from the
Luther Computer Science Home Page}</p>
</div></blockquote>
<p id="fig-cshome">If you study the graph in <a class="reference internal" href="#fig-cshome"><em>Figure 41</em></a> you might make some
interesting observations. First you might notice that many of the other
web sites on the graph are other Luther College web sites. Second, you
might notice that there are several links to other colleges in Iowa.
Third, you might notice that there are several links to other liberal
arts colleges. You might conclude from this that there is some
underlying structure to the web that clusters together web sites that
are similar on some level.</p>
<p>One graph algorithm that can help find clusters of highly interconnected
vertices in a graph is called the strongly connected components
algorithm (<strong>SCC</strong>). We formally define a <strong>strongly connected
component</strong>, <span class="math">\(C\)</span>, of a graph <span class="math">\(G\)</span>, as the largest subset
of vertices <span class="math">\(C \subset V\)</span> such that for every pair of vertices
<span class="math">\(v, w \in C\)</span> we have a path from <span class="math">\(v\)</span> to <span class="math">\(w\)</span> and
a path from <span class="math">\(w\)</span> to <span class="math">\(v\)</span>. <a class="reference internal" href="#fig-scc1"><em>Figure 42</em></a> shows a simple
graph with three strongly connected components. The strongly connected
components are identified by the different shaded areas.</p>
<blockquote>
<div><blockquote>
<div><div class="figure align-center">
<img alt="image" src="_images/scc1.png" />
<p class="caption">image</p>
</div>
</div></blockquote>
<p>{A Directed Graph with Three Strongly Connected Components}</p>
</div></blockquote>
<p id="fig-scc1">Once the strongly connected components have been identified we can show
a simplified view of the graph by combining all the vertices in one
strongly connected component into a single larger vertex. The simplified
version of the graph in <a class="reference internal" href="#fig-scc1"><em>Figure x</em></a> is shown in <a class="reference internal" href="#fig-scc2"><em>Figure&nbsp;x</em></a>.</p>
<blockquote>
<div><blockquote>
<div><div class="figure align-center">
<img alt="image" src="_images/scc2.png" />
<p class="caption">image</p>
</div>
</div></blockquote>
<p>{The Reduced Graph}</p>
</div></blockquote>
<p id="fig-scc2">Once again we will see that we can create a very powerful and efficient
algorithm by making use of a depth first search. Before we tackle the
main SCC algorithm we must look at one other definition. The
transposition of a graph <span class="math">\(G\)</span> is defined as the graph
<span class="math">\(G^T\)</span> where all the edges in the graph have been reversed. That
is, if there is a directed edge from node A to node B in the original
graph then <span class="math">\(G^T\)</span> will contain and edge from node B to node A.
<a class="reference internal" href="#fig-transpose"><em>Figure 46</em></a> shows a simple graph and its transposition.</p>
<blockquote>
<div>[a graph <span class="math">\(G\)</span>] {</div></blockquote>
<blockquote id="fig-tpa">
<div><blockquote>
<div><div class="figure align-center">
<img alt="image" src="_images/transpose1.png" />
<p class="caption">image</p>
</div>
</div></blockquote>
<p>}[the transposition of <span class="math">\(G\)</span>, <span class="math">\(G^T\)</span>] {</p>
</div></blockquote>
<blockquote id="fig-tpb">
<div><blockquote>
<div><div class="figure align-center">
<img alt="image" src="_images/transpose2.png" />
<p class="caption">image</p>
</div>
</div></blockquote>
<p>} {A Graph <span class="math">\(G\)</span> and Its Transpose <span class="math">\(G^T\)</span>}</p>
</div></blockquote>
<p id="fig-transpose">Look at <a class="reference internal" href="#fig-transpose"><em>Figure 46</em></a> again. Notice that the graph in
<a class="reference internal" href="#fig-tpa"><em>Figure 44</em></a> has two strongly connected components. Now look at the
.. _fig_tpb. Notice that it has the same two strongly connected
components.</p>
<p>We can now describe the algorithm to compute the strongly connected
components for a graph.</p>
<ol class="arabic simple">
<li>Call <tt class="docutils literal"><span class="pre">dfs</span></tt> for the graph <span class="math">\(G\)</span> to compute the finish times
for each vertex.</li>
<li>Compute <span class="math">\(G^T\)</span>.</li>
<li>Call <tt class="docutils literal"><span class="pre">dfs</span></tt> for the graph <span class="math">\(G^T\)</span> but in the main loop of DFS
explore each vertex in decreasing order of finish time.</li>
<li>Each tree in the forest computed in step 3 is a strongly connected
component. Output the vertex ids for each vertex in each tree in the
forest to identify the component.</li>
</ol>
<p>Lets trace the operation of the steps described above on the example
graph in <em class="xref std std-ref">Figure x</em> shows the starting and
finishing times computed for the original graph by the DFS algorithm.
<a class="reference internal" href="#fig-sccalgb"><em>Figure 48</em></a> shows the starting and finishing times computed by
running DFS on the transposed graph.</p>
<blockquote>
<div>[finishing times for the original graph <span class="math">\(G\)</span>] {</div></blockquote>
<blockquote id="fig-sccalga">
<div><blockquote>
<div><div class="figure align-center">
<img alt="image" src="_images/scc1a.png" />
<p class="caption">image</p>
</div>
</div></blockquote>
<p>}[finishing times for <span class="math">\(G^T\)</span>] {</p>
</div></blockquote>
<blockquote id="fig-sccalgb">
<div><blockquote>
<div><div class="figure align-center">
<img alt="image" src="_images/scc1b.png" />
<p class="caption">image</p>
</div>
</div></blockquote>
<p>} {Computing the Strongly Connected Components}</p>
</div></blockquote>
<p id="fig-scctrace">Finally, <a class="reference internal" href="#fig-sccforest"><em>Figure 50</em></a> shows the forest of three trees produced
in step 3 of the strongly connected component algorithm. You will notice
that we do not provide you with the Python code for the SCC algorithm,
we leave writing this program as an exercise.</p>
<blockquote>
<div><img alt="image4" src="_images/sccforest.png" /> {The Strongly Connected Components as a Forest of Trees}</div></blockquote>
</div>
<div class="section" id="shortest-path-problems">
<span id="fig-sccforest"></span><h2>Shortest Path Problems<a class="headerlink" href="#shortest-path-problems" title="Permalink to this headline">¶</a></h2>
<p>When you surf the web, send an email, or log in to a laboratory computer
from another location on campus a lot of work is going on behind the
scenes to get the information on your computer transferred to another
computer. The in-depth study of how information flows from one computer
to another over the Internet is the primary topic for a class in
computer networking. However, we will talk about how the Internet works
just enough to understand another very important graph algorithm.</p>
<blockquote>
<div><blockquote>
<div><div class="figure align-center">
<img alt="image" src="_images/Internet.png" />
<p class="caption">image</p>
</div>
</div></blockquote>
<p>{Overview of Connectivity in the Internet}</p>
</div></blockquote>
<p id="fig-inet"><a class="reference internal" href="#fig-inet"><em>Figure 51</em></a> shows you a high-level overview of how communication
on the Internet works. When you use your browser to request a web page
from a server, the request must travel over your local area network and
out onto the Internet through a router. The request travels over the
Internet and eventually arrives at a router for the local area network
where the server is located. The web page you requested then travels
back through the same routers to get to your browser. Inside the cloud
labelled “Internet” in <a class="reference internal" href="#fig-inet"><em>Figure 51</em></a> are additional routers. The job
of all of these routers is to work together to get your information from
place to place. You can see there are many routers for yourself if your
computer supports the <tt class="docutils literal"><span class="pre">traceroute</span></tt> command. <a class="reference internal" href="#fig-routes"><em>Figure 52</em></a> shows
the output of the <tt class="docutils literal"><span class="pre">traceroute</span></tt> command which illustrates that there
are 13 routers between the web server at Luther College and the mail
server at the University of Minnesota.</p>
<p>{</p>
<blockquote>
<div><div class="highlight-python"><pre>1  192.203.196.1
2  hilda.luther.edu (216.159.75.1)
3  ICN-Luther-Ether.icn.state.ia.us (207.165.237.137)
4  ICN-ISP-1.icn.state.ia.us (209.56.255.1)
5  p3-0.hsa1.chi1.bbnplanet.net (4.24.202.13)
6  ae-1-54.bbr2.Chicago1.Level3.net (4.68.101.97)
7  so-3-0-0.mpls2.Minneapolis1.Level3.net (64.159.4.214)
8  ge-3-0.hsa2.Minneapolis1.Level3.net (4.68.112.18)
9  p1-0.minnesota.bbnplanet.net (4.24.226.74)
10  TelecomB-BR-01-V4002.ggnet.umn.edu (192.42.152.37)
11  TelecomB-BN-01-Vlan-3000.ggnet.umn.edu (128.101.58.1)
12  TelecomB-CN-01-Vlan-710.ggnet.umn.edu (128.101.80.158)
13  baldrick.cs.umn.edu (128.101.80.129)(N!)  88.631 ms (N!)</pre>
</div>
<p>{Routers from One Host to the Next over the Internet}</p>
</div></blockquote>
<p id="fig-routes">}</p>
<p>Each router on the Internet is connected to one or more other routers.
So if you run the <tt class="docutils literal"><span class="pre">traceroute</span></tt> command at different times of the day,
you are likely to see that your information flows through different
routers at different times. This is because there is a cost associated
with each connection between a pair of routers that depends on the
volume of traffic, the time of day, and many other factors. By this time
it will not surprise you to learn that we can represent the network of
routers as a graph with weighted edges.</p>
<blockquote>
<div><blockquote>
<div><div class="figure align-center">
<img alt="image" src="_images/routeGraph.png" />
<p class="caption">image</p>
</div>
</div></blockquote>
<p>{Connections and Weights between Routers in the Internet}</p>
</div></blockquote>
<p id="fig-network"><a class="reference internal" href="#fig-network"><em>Figure 53</em></a> shows a small example of a weighted graph that
represents the interconnection of routers in the Internet. The problem
that we want to solve is to find the path with the smallest total weight
along which to route any given message. This problem should sound
familiar because it is similar to the problem we solved using a breadth
first search, except that here we are concerned with the total weight of
the path rather than the number of hops in the path. It should be noted
that if all the weights are equal, the problem is the same.</p>
<div class="section" id="dijkstras-algorithm">
<h3>Dijkstra’s Algorithm<a class="headerlink" href="#dijkstras-algorithm" title="Permalink to this headline">¶</a></h3>
<p>The algorithm we are going to use to determine the shortest path is
called “Dijkstra’s algorithm.” Dijkstra’s algorithm is an iterative
algorithm that provides us with the shortest path from one particular
starting node to all other nodes in the graph. Again this is similar to
the results of a breadth first search.</p>
<p>To keep track of the total cost from the start node to each destination
we will make use of the <tt class="docutils literal"><span class="pre">dist</span></tt> instance variable in the Vertex class.
The <tt class="docutils literal"><span class="pre">dist</span></tt> instance variable will contain the current total weight of
the smallest weight path from the start to the vertex in question. The
algorithm iterates once for every vertex in the graph; however, the
order that we iterate over the vertices is controlled by a priority
queue. The value that is used to determine the order of the objects in
the priority queue is <tt class="docutils literal"><span class="pre">dist</span></tt>. When a vertex is first created <tt class="docutils literal"><span class="pre">dist</span></tt>
is set to a very large number. Theoretically you would set <tt class="docutils literal"><span class="pre">dist</span></tt> to
infinity, but in practice we just set it to a number that is larger than
any real distance we would have in the problem we are trying to solve.</p>
<p>The code for Dijkstra’s algorithm {dijkstra-59} is shown in
Listing&nbsp;{lst:dij}. When the algorithm finishes the distances are set
correctly as are the predecessor links for each vertex in the graph.</p>
<p>Dijkstra’s algorithm uses a priority queue. You may recall that a
priority queue is based on the heap that we implemented in
Chapter&nbsp;{chap:tree}. There are a couple of differences between the
simple implementation in Chapter&nbsp;{chap:tree} and the implementation we
use for Dijkstra’s algorithm. First, the <tt class="docutils literal"><span class="pre">PriorityQueue</span></tt> class stores
tuples of key, value pairs. This is important for Dijkstra’s algorithm
as the key in the priority queue must match the key of the vertex in the
graph. Secondly the value is used for deciding the priority, and thus
the position of the key in the priority queue. In this implementation we
use the distance to the vertex as the priority because as we will see
when we are exploring the next vertex, we always want to explore the
vertex that has the smallest distance. The second difference is the
addition of the <tt class="docutils literal"><span class="pre">decreaseKey</span></tt> method. As you can see on
line&nbsp;{lst:dij:dk} this method is used when the distance to a vertex that
is already in the queue is reduced, and thus moves that vertex toward
the front of the queue.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">pythonds.graphs</span> <span class="kn">import</span> <span class="n">PriorityQueue</span><span class="p">,</span> <span class="n">Graph</span><span class="p">,</span> <span class="n">Vertex</span>
<span class="k">def</span> <span class="nf">dijkstra</span><span class="p">(</span><span class="n">aGraph</span><span class="p">,</span><span class="n">start</span><span class="p">):</span>
    <span class="n">pq</span> <span class="o">=</span> <span class="n">PriorityQueue</span><span class="p">()</span>
    <span class="n">start</span><span class="o">.</span><span class="n">setDistance</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">pq</span><span class="o">.</span><span class="n">buildHeap</span><span class="p">([(</span><span class="n">v</span><span class="o">.</span><span class="n">getDistance</span><span class="p">(),</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">aGraph</span><span class="p">])</span>
    <span class="k">while</span> <span class="ow">not</span> <span class="n">pq</span><span class="o">.</span><span class="n">isEmpty</span><span class="p">():</span>   <span class="c">#// \label{lst:dij:while}</span>
        <span class="n">currentVert</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="n">delMin</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">nextVert</span> <span class="ow">in</span> <span class="n">currentVert</span><span class="o">.</span><span class="n">getConnections</span><span class="p">():</span>  <span class="c">#// \label{lst:dij:for}</span>
            <span class="n">newDist</span> <span class="o">=</span> <span class="n">currentVert</span><span class="o">.</span><span class="n">getDistance</span><span class="p">()</span> \
                    <span class="o">+</span> <span class="n">currentVert</span><span class="o">.</span><span class="n">getWeight</span><span class="p">(</span><span class="n">nextVert</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">newDist</span> <span class="o">&lt;</span> <span class="n">nextVert</span><span class="o">.</span><span class="n">getDistance</span><span class="p">():</span>
                <span class="n">nextVert</span><span class="o">.</span><span class="n">setDistance</span><span class="p">(</span> <span class="n">newDist</span> <span class="p">)</span>
                <span class="n">nextVert</span><span class="o">.</span><span class="n">setPred</span><span class="p">(</span><span class="n">currentVert</span><span class="p">)</span>
                <span class="n">pq</span><span class="o">.</span><span class="n">decreaseKey</span><span class="p">(</span><span class="n">nextVert</span><span class="p">,</span><span class="n">newDist</span><span class="p">)</span>  <span class="c">#// \label{lst:dij:dk}</span>
</pre></div>
</div>
<p>Let’s walk through an application of Dijkstra’s algorithm one vertex at
a time using <a class="reference internal" href="#fig-dijstep"><em>Figure 60</em></a> as our guide. We begin with the vertex
<span class="math">\(u\)</span>. The three vertices adjacent to <span class="math">\(u\)</span> are
<span class="math">\(v,w,\)</span> and <span class="math">\(x\)</span>. Since the initial distances to
<span class="math">\(v,w,\)</span> and <span class="math">\(x\)</span> are all initialized to <tt class="docutils literal"><span class="pre">sys.maxint</span></tt>,
the new costs to get to them through the start node are all their direct
costs. So we update the costs to each of these three nodes. We also set
the predecessor for each node to <span class="math">\(u\)</span> and we add each node to the
priority queue. We use the distance as the key for the priority queue.
The state of the algorithm is shown in <a class="reference internal" href="#fig-dija"><em>Figure 54</em></a>.</p>
<p>In the next iteration of the <tt class="docutils literal"><span class="pre">while</span></tt> loop we examine the vertices that
are adjacent to <span class="math">\(x\)</span>. The vertex <span class="math">\(x\)</span> is next because it
has the lowest overall cost and therefore bubbled its way to the
beginning of the priority queue. At <span class="math">\(x\)</span> we look at its neighbors
<span class="math">\(u,v,w\)</span> and <span class="math">\(y\)</span>. For each neighboring vertex we check to
see if the distance to that vertex through <span class="math">\(x\)</span> is smaller than
the previously known distance. Obviously this is the case for
<span class="math">\(y\)</span> since its distance was <tt class="docutils literal"><span class="pre">sys.maxint</span></tt>. It is not the case
for <span class="math">\(u\)</span> or <span class="math">\(v\)</span> since their distances are 0 and 2
respectively. However, we now learn that the distance to <span class="math">\(w\)</span> is
smaller if we go through <span class="math">\(x\)</span> than from <span class="math">\(u\)</span> directly to
<span class="math">\(w\)</span>. Since that is the case we update <span class="math">\(w\)</span> with a new
distance and change the predecessor for <span class="math">\(w\)</span> from <span class="math">\(u\)</span> to
<span class="math">\(x\)</span>. See <a class="reference internal" href="#fig-dijb"><em>Figure 55</em></a> for the state of all the vertices.</p>
<p>The next step is to look at the vertices neighboring <span class="math">\(v\)</span>. This
step results in no changes to the graph, so we move on to node
<span class="math">\(y\)</span>. At node <span class="math">\(y\)</span> we discover that it is cheaper to get
to both <span class="math">\(w\)</span> and <span class="math">\(z\)</span>, so we adjust the distances and
predecessor links accordingly. Finally we check nodes <span class="math">\(w\)</span> and
<span class="math">\(z\)</span>. However, no additional changes are found and so the
priority queue is empty and Dijkstra’s algorithm exits.</p>
<blockquote>
<div>[] {</div></blockquote>
<blockquote id="fig-dija">
<div><blockquote>
<div><div class="figure align-center">
<img alt="image" src="_images/dijkstraa.png" />
<p class="caption">image</p>
</div>
</div></blockquote>
<p>}[] {</p>
</div></blockquote>
<blockquote id="fig-dijb">
<div><blockquote>
<div><div class="figure align-center">
<img alt="image" src="_images/dijkstrab.png" />
<p class="caption">image</p>
</div>
</div></blockquote>
<p>}[] {</p>
</div></blockquote>
<blockquote id="fig-dijc">
<div><blockquote>
<div><div class="figure align-center">
<img alt="image" src="_images/dijkstrac.png" />
<p class="caption">image</p>
</div>
</div></blockquote>
<p>} [] {</p>
</div></blockquote>
<blockquote id="fig-dijd">
<div><blockquote>
<div><div class="figure align-center">
<img alt="image" src="_images/dijkstrad.png" />
<p class="caption">image</p>
</div>
</div></blockquote>
<p>}[] {</p>
</div></blockquote>
<blockquote id="fig-dije">
<div><blockquote>
<div><div class="figure align-center">
<img alt="image" src="_images/dijkstrae.png" />
<p class="caption">image</p>
</div>
</div></blockquote>
<p>}[] {</p>
</div></blockquote>
<blockquote id="fig-dijf">
<div><blockquote>
<div><div class="figure align-center">
<img alt="image" src="_images/dijkstraf.png" />
<p class="caption">image</p>
</div>
</div></blockquote>
<p>} {Tracing Dijkstra’s Algorithm}</p>
</div></blockquote>
<p id="fig-dijstep">It is important to note that Dijkstra’s algorithm works only when the
weights are all positive. You should convince yourself that if you
introduced a negative weight on one of the edges to the graph in
<a class="reference internal" href="#fig-network"><em>Figure 53</em></a> that the algorithm would never exit.</p>
<p>We will note that to route messages through the Internet, other
algorithms are used for finding the shortest path. One of the problems
with using Dijkstra’s algorithm on the Internet is that you must have a
complete representation of the graph in order for the algorithm to run.
The implication of this is that every router has a complete map of all
the routers in the Internet. In practice this is not the case and other
variations of the algorithm allow each router to discover the graph as
they go. One such algorithm that you may want to read about is called
the “distance vector” routing algorithm.</p>
</div>
<div class="section" id="analysis-of-dijkstras-algorithm">
<h3>Analysis of Dijkstra’s Algorithm<a class="headerlink" href="#analysis-of-dijkstras-algorithm" title="Permalink to this headline">¶</a></h3>
<p>{sec:analys-dijkstr-algor}</p>
<p>Finally, let us look at the running time of Dijkstra’s algorithm. We
first note that building the priority queue takes <span class="math">\(O(V)\)</span> time
since we initially add every vertex in the graph to the priority queue.
Once the queue is constructed the <tt class="docutils literal"><span class="pre">while</span></tt> loop on line&nbsp;{lst:dij:while}
is executed once for every vertex since vertices are all added at the
beginning and only removed after that. Within that loop each call to
<tt class="docutils literal"><span class="pre">delMin</span></tt>, takes <span class="math">\(O(\log V)\)</span> time. Taken together that part of
the loop and the calls to delMin take <span class="math">\(O(V \log(V))\)</span>. The
<tt class="docutils literal"><span class="pre">for</span></tt> loop on line&nbsp;{lst:dij:for} is executed once for each edge in the
graph, and within the <tt class="docutils literal"><span class="pre">for</span></tt> loop the call to <tt class="docutils literal"><span class="pre">decreaseKey</span></tt> takes
time <span class="math">\(O(E
\log(V))\)</span>. So the combined running time is :math:` O((V+E) log(V))`.</p>
</div>
<div class="section" id="prims-spanning-tree-algorithm">
<h3>Prim’s Spanning Tree Algorithm<a class="headerlink" href="#prims-spanning-tree-algorithm" title="Permalink to this headline">¶</a></h3>
<p>For our last graph algorithm let’s consider a problem that online game
designers and Internet radio providers face. The problem is that they
want to efficiently transfer a piece of information to anyone and
everyone who may be listening. This is important in gaming so that all
the players know the very latest position of every other player. This is
important for Internet radio so that all the listeners that are tuned in
are getting all the data they need to reconstruct the song they are
listening to. <em class="xref std std-ref">Figure x</em> illustrates the broadcast problem.</p>
<blockquote>
<div><blockquote>
<div><div class="figure align-center">
<img alt="image" src="_images/bcast1.png" />
<p class="caption">image</p>
</div>
</div></blockquote>
<p>{The Broadcast Problem} .. _fig_bcast1</p>
</div></blockquote>
<p>There are some brute force solutions to this problem, so let’s look at
them first to help understand the broadcast problem better. This will
also help you appreciate the solution that we will propose when we are
done. To begin, the broadcast host has some information that the
listeners all need to receive. The simplest solution is for the
broadcasting host to keep a list of all of the listeners and send
individual messages to each. In <em class="xref std std-ref">Figure x</em> we show a small
network with a broadcaster and some listeners. Using this first
approach, four copies of every message would be sent. Assuming that the
least cost path is used, let’s see how many times each router would
handle the same message.</p>
<p>All messages from the broadcaster go through router A, so A sees all
four copies of every message. Router C sees only one copy of each
message for its listener. However, routers B and D would see three
copies of every message since routers B and D are on the cheapest path
for listeners 1, 2, and 3. When you consider that the broadcast host
must send hundreds of messages each second for a radio broadcast, that
is a lot of extra traffic.</p>
<p>A brute force solution is for the broadcast host to send a single copy
of the broadcast message and let the routers sort things out. In this
case, the easiest solution is a strategy called <strong>uncontrolled
flooding</strong>. The flooding strategy works as follows. Each message starts
with a time to live (<tt class="docutils literal"><span class="pre">ttl</span></tt>) value set to some number greater than or
equal to the number of edges between the broadcast host and its most
distant listener. Each router gets a copy of the message and passes the
message on to <em>all</em> of its neighboring routers. When the message is
passed on the <tt class="docutils literal"><span class="pre">ttl</span></tt> is decreased. Each router continues to send copies
of the message to all its neighbors until the <tt class="docutils literal"><span class="pre">ttl</span></tt> value reaches 0.
It is easy to convince yourself that uncontrolled flooding generates
many more unnecessary messages than our first strategy.</p>
<p>The solution to this problem lies in the construction of a minimum
weight <strong>spanning tree</strong>. Formally we define the minimum spanning tree
<span class="math">\(T\)</span> for a graph <span class="math">\(G = (V,E)\)</span> as follows. <span class="math">\(T\)</span> is
an acyclic subset of <span class="math">\(E\)</span> that connects all the vertices in
<span class="math">\(V\)</span>. The sum of the weights of the edges in T is minimized.</p>
<p><em class="xref std std-ref">Figure x</em> shows a simplified version of the broadcast graph and
highlights the edges that form a minimum spanning tree for the graph.
Now to solve our broadcast problem, the broadcast host simply sends a
single copy of the broadcast message into the network. Each router
forwards the message to any neighbor that is part of the spanning tree,
excluding the neighbor that just sent it the message. In this example A
forwards the message to B. B forwards the message to D and C. D forwards
the message to E, which forwards it to F, which forwards it to G. No
router sees more than one copy of any message, and all the listeners
that are interested see a copy of the message.</p>
<blockquote>
<div><blockquote>
<div><div class="figure align-center">
<img alt="image" src="_images/mst1.png" />
<p class="caption">image</p>
</div>
</div></blockquote>
<p>{Minimum Spanning Tree for the Broadcast Graph} .. _fig_mst1</p>
</div></blockquote>
<p>The algorithm we will use to solve this problem is called Prim’s
algorithm. Prim’s algorithm belongs to a family of algorithms called the
“greedy algorithms” because at each step we will choose the cheapest
next step. In this case the cheapest next step is to follow the edge
with the lowest weight. Our last step is to develop Prim’s algorithm.</p>
<p>The basic idea in constructing a spanning tree is as follows:</p>
<ol class="arabic simple">
<li>While <span class="math">\(T\)</span> is not yet a spanning tree<ol class="arabic">
<li>Find an edge that is safe to add to the tree</li>
<li>Add the new edge to <span class="math">\(T\)</span></li>
</ol>
</li>
</ol>
<p>The trick is in the step that directs us to “find an edge that is safe.”
We define a safe edge as any edge that connects a vertex that is in the
spanning tree to a vertex that is not in the spanning tree. This ensures
that the tree will always remain a tree and therefore have no cycles.</p>
<p>The Python code to implement Prim’s algorithm is shown in
Listing&nbsp;{lst:prim}. Prim’s algorithm is similar to Dijkstra’s algorithm
in that they both use a priority queue to select the next vertex to add
to the growing graph.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">pythonds.graphs</span> <span class="kn">import</span> <span class="n">PriorityQueue</span><span class="p">,</span> <span class="n">Graph</span><span class="p">,</span> <span class="n">Vertex</span>
<span class="k">def</span> <span class="nf">prim</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">start</span><span class="p">):</span>
    <span class="n">pq</span> <span class="o">=</span> <span class="n">PriorityQueue</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">G</span><span class="p">:</span>
        <span class="n">v</span><span class="o">.</span><span class="n">setDistance</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">maxsize</span><span class="p">)</span>
        <span class="n">v</span><span class="o">.</span><span class="n">setPred</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
    <span class="n">start</span><span class="o">.</span><span class="n">setDistance</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">pq</span><span class="o">.</span><span class="n">buildHeap</span><span class="p">([(</span><span class="n">v</span><span class="o">.</span><span class="n">getDistance</span><span class="p">(),</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">G</span><span class="p">])</span>
    <span class="k">while</span> <span class="ow">not</span> <span class="n">pq</span><span class="o">.</span><span class="n">isEmpty</span><span class="p">():</span>
        <span class="n">currentVert</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="n">delMin</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">nextVert</span> <span class="ow">in</span> <span class="n">currentVert</span><span class="o">.</span><span class="n">getConnections</span><span class="p">():</span>
          <span class="n">newCost</span> <span class="o">=</span> <span class="n">currentVert</span><span class="o">.</span><span class="n">getWeight</span><span class="p">(</span><span class="n">nextVert</span><span class="p">)</span> \
                  <span class="o">+</span> <span class="n">currentVert</span><span class="o">.</span><span class="n">getDistance</span><span class="p">()</span>
          <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">pq</span> <span class="ow">and</span> <span class="n">newCost</span><span class="o">&lt;</span><span class="n">nextVert</span><span class="o">.</span><span class="n">getDistance</span><span class="p">():</span>
              <span class="n">nextVert</span><span class="o">.</span><span class="n">setPred</span><span class="p">(</span><span class="n">currentVert</span><span class="p">)</span>
              <span class="n">nextVert</span><span class="o">.</span><span class="n">setDistance</span><span class="p">(</span><span class="n">newCost</span><span class="p">)</span>
              <span class="n">pq</span><span class="o">.</span><span class="n">decreaseKey</span><span class="p">(</span><span class="n">nextVert</span><span class="p">,</span><span class="n">newCost</span><span class="p">)</span>
</pre></div>
</div>
<p><a class="reference internal" href="#fig-primtrace"><em>Figure 68</em></a> shows the algorithm in operation on our sample
tree. We begin with the starting vertex as A. The distances to all the
other vertices are initialized to infinity. Looking at the neighbors of
A we can update distances to two of the additional vertices B and C
because the distances to B and C through A are less than infinite. This
moves B and C to the front of the priority queue. Update the predecessor
links for B and C by setting them to point to A. It is important to note
that we have not formally added B or C to the spanning tree yet. A node
is not considered to be part of the spanning tree until it is removed
from the priority queue.</p>
<p>Since B has the smallest distance we look at B next. Examining B’s
neighbors we see that D and E can be updated. Both D and E get new
distance values and their predecessor links are updated. Moving on to
the next node in the priority queue we find C. The only node C is
adjacent to that is still in the priority queue is F, thus we can update
the distance to F and adjust F’s position in the priority queue.</p>
<p>Now we examine the vertices adjacent to node D. We find that we can
update E and reduce the distance to E from 6 to 4. When we do this we
change the predecessor link on E to point back to D, thus preparing it
to be grafted into the spanning tree but in a different location. The
rest of the algorithm proceeds as you would expect, adding each new node
to the tree.</p>
<blockquote>
<div>[] {</div></blockquote>
<blockquote id="fig-prima">
<div><blockquote>
<div><div class="figure align-center">
<img alt="image" src="_images/prima.png" />
<p class="caption">image</p>
</div>
</div></blockquote>
<p>}[] {</p>
</div></blockquote>
<blockquote id="fig-primb">
<div><blockquote>
<div><div class="figure align-center">
<img alt="image" src="_images/primb.png" />
<p class="caption">image</p>
</div>
</div></blockquote>
<p>}[] {</p>
</div></blockquote>
<blockquote id="fig-primc">
<div><blockquote>
<div><div class="figure align-center">
<img alt="image" src="_images/primc.png" />
<p class="caption">image</p>
</div>
</div></blockquote>
<p>} [] {</p>
</div></blockquote>
<blockquote id="fig-primd">
<div><blockquote>
<div><div class="figure align-center">
<img alt="image" src="_images/primd.png" />
<p class="caption">image</p>
</div>
</div></blockquote>
<p>}[] {</p>
</div></blockquote>
<blockquote id="fig-prime">
<div><blockquote>
<div><div class="figure align-center">
<img alt="image" src="_images/prime.png" />
<p class="caption">image</p>
</div>
</div></blockquote>
<p>}[] {</p>
</div></blockquote>
<blockquote id="fig-primf">
<div><blockquote>
<div><div class="figure align-center">
<img alt="image" src="_images/primf.png" />
<p class="caption">image</p>
</div>
</div></blockquote>
<p>} [] {</p>
</div></blockquote>
<blockquote id="fig-primg">
<div><blockquote>
<div><div class="figure align-center">
<img alt="image" src="_images/primg.png" />
<p class="caption">image</p>
</div>
</div></blockquote>
<p>} {Tracing Prim’s Algorithm}</p>
</div></blockquote>
</div>
</div>
<div class="section" id="summary">
<span id="fig-primtrace"></span><h2>Summary<a class="headerlink" href="#summary" title="Permalink to this headline">¶</a></h2>
<p>In this chapter we have looked at the graph abstract data type, and some
implementations of a graph. A graph enables us to solve many problems
provided we can transform the original problem into something that can
be represented by a graph. In particular, we have seen that graphs are
useful to solve problems in the following general areas.</p>
<ul class="simple">
<li>Breadth first search for finding the unweighted shortest path.</li>
<li>Dijkstra’s algorithm for weighted shortest path.</li>
<li>Depth first search for graph exploration.</li>
<li>Strongly connected components for simplifying a graph.</li>
<li>Topological sort for ordering tasks.</li>
<li>Minimum weight spanning trees for broadcasting messages.</li>
</ul>
</div>
<div class="section" id="key-terms">
<h2>Key Terms<a class="headerlink" href="#key-terms" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div>acyclic graph &amp; adjacency list
adjacency matrix &amp; adjacent
breadth first search (BFS) &amp; cycle
cyclic graph &amp; DAG
depth first forest &amp; depth first search (DFS)
digraph &amp; directed acyclic graph (DAG)
directed graph &amp; edge cost
edge &amp; parenthesis property
path &amp; shortest path
spanning tree &amp; strongly connected components (SCC)
topological sort &amp; uncontrolled flooding
vertex &amp; weight</div></blockquote>
</div>
<div class="section" id="discussion-questions">
<h2>Discussion Questions<a class="headerlink" href="#discussion-questions" title="Permalink to this headline">¶</a></h2>
<ol class="arabic">
<li><p class="first">Draw the graph corresponding to the following adjacency matrix.
{q:am}</p>
<blockquote>
<div><div class="figure align-center">
<img alt="image" src="_images/adjMatEx.png" />
<p class="caption">image</p>
</div>
</div></blockquote>
</li>
<li><p class="first">Draw the graph corresponding to the following list of edges. {q:al}</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="36%" />
<col width="27%" />
<col width="36%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><p class="first last">from</p>
</th>
<th class="head"><p class="first last">to</p>
</th>
<th class="head"><p class="first last">cost</p>
</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><p class="first last">1</p>
</td>
<td><p class="first last">2</p>
</td>
<td><p class="first last">10</p>
</td>
</tr>
<tr class="row-odd"><td><p class="first last">1</p>
</td>
<td><p class="first last">3</p>
</td>
<td><p class="first last">15</p>
</td>
</tr>
<tr class="row-even"><td><p class="first last">1</p>
</td>
<td><p class="first last">6</p>
</td>
<td><p class="first last">5</p>
</td>
</tr>
<tr class="row-odd"><td><p class="first last">2</p>
</td>
<td><p class="first last">3</p>
</td>
<td><p class="first last">7</p>
</td>
</tr>
<tr class="row-even"><td><p class="first last">3</p>
</td>
<td><p class="first last">4</p>
</td>
<td><p class="first last">7</p>
</td>
</tr>
<tr class="row-odd"><td><p class="first last">3</p>
</td>
<td><p class="first last">6</p>
</td>
<td><p class="first last">10</p>
</td>
</tr>
<tr class="row-even"><td><p class="first last">4</p>
</td>
<td><p class="first last">5</p>
</td>
<td><p class="first last">7</p>
</td>
</tr>
<tr class="row-odd"><td><p class="first last">6</p>
</td>
<td><p class="first last">4</p>
</td>
<td><p class="first last">5</p>
</td>
</tr>
<tr class="row-even"><td><p class="first last">5</p>
</td>
<td><p class="first last">6</p>
</td>
<td><p class="first last">13</p>
</td>
</tr>
</tbody>
</table>
</div></blockquote>
</li>
<li><p class="first">Ignoring the weights, perform a breadth first search on the graph
from question {q:am}.</p>
</li>
<li><p class="first">What is the Big-O running time of the <tt class="docutils literal"><span class="pre">buildGraph</span></tt> function in
Listing&nbsp;{lst:laddergraph}?</p>
</li>
<li><p class="first">Derive the Big-O running time for the topological sort algorithm.</p>
</li>
<li><p class="first">Derive the Big-O running time for the strongly connected components
algorithm.</p>
</li>
<li><p class="first">Show each step in applying Dijkstra’s algorithm to the graph in
question {q:al}.</p>
</li>
<li><p class="first">Using Prim’s algorithm, find the minimum weight spanning tree for the
graph in question {q:am}.</p>
</li>
<li><p class="first">Draw a dependency graph illustrating the steps needed to send an
email. Perform a topological sort on your graph.</p>
</li>
<li><p class="first">Derive an expression for the base of the exponent used in expressing
the running time of the knights tour.</p>
</li>
<li><p class="first">Explain why the general DFS algorithm is not suitable for solving the
knights tour problem.</p>
</li>
<li><p class="first">What is the Big-O running time for Prim’s minimum spanning tree
algorithm?</p>
</li>
</ol>
</div>
<div class="section" id="programming-exercises">
<h2>Programming Exercises<a class="headerlink" href="#programming-exercises" title="Permalink to this headline">¶</a></h2>
<ol class="arabic simple">
<li>Modify the depth first search function to produce a topological sort.</li>
<li>Modify the depth first search to produce strongly connected
components.</li>
<li>Write the <tt class="docutils literal"><span class="pre">transpose</span></tt> method for the <tt class="docutils literal"><span class="pre">Graph</span></tt> class.</li>
<li>Using breadth first search write an algorithm that can determine the
shortest path from each vertex to every other vertex. This is called
the all pairs shortest path problem.</li>
<li>Using breadth first search revise the maze program from
Chapter&nbsp;{chap:recursion} to find the shortest path out of a maze.</li>
<li>Write a program to solve the following problem: You have two jugs, a
4-gallon and a 3-gallon. Neither of the jugs has markings on them.
There is a pump that can be used to fill the jugs with water. How can
you get exactly two gallons of water in the 4 gallon jug?</li>
<li>Generalize the problem above so that the parameters to your solution
include the sizes of each jug and the final amount of water to be
left in the larger jug.</li>
<li>Write a program that solves the following problem: Three missionaries
and three cannibals come to a river and find a boat that holds two
people. Everyone must get across the river to continue on the
journey. However, if the cannibals ever outnumber the missionaries on
either bank, the missionaries will be eaten. Find a series of
crossings that will get everyone safely to the other side of the
river.</li>
</ol>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="trees.html" title="Trees"
             >previous</a> |</li>
        <li><a href="index.html">Problem Solving with Algorithms and Data Structures 3.0 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2011, Brad Miller, Kent Lee, David Ranum.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.2pre.
    </div>
  </body>
</html>